<#@ template language="C#" hostspecific="true" #>
<#@ include file="$(SolutionDir)Shared\MultipleOutputHelper.ttinclude" #>
<#@ include file="$(SolutionDir)Shared\VisualStudioHelper.ttinclude" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#
	/*********************/
	/** CUSTOM SETTINGS **/
	/*********************/

	// Namespace des fichiers générés. Si vide DefaultNamespace du projet/répertoire courant.
	string Namespace = "";

	// Limite le traitement aux classes dans ce projet.
	string SourceProject = "Tmpi.Pyrene.Services.ServiceModel";
	
	// true pour générer des classes partial.
	bool MakeClassesPartial = true;

	// true pour générer chaque classe dans un fichier séparé.
	bool SplitIntoMultipleFiles = true;

	// RegExp pour filtrer globalement les classes traitées, null pour tout inclure et/ou ne rien exclure.
	Regex ClassFilterInclude = null;
	Regex ClassFilterExclude = null;

#>
<#
	// namespace
	var fileNamespace = Namespace;
	if (string.IsNullOrWhiteSpace(fileNamespace))
    {
		fileNamespace = VisualStudioHelper.CurrentFileNamespace;
	}

	// get a reference to the project of this t4 template
	var srcProject = VisualStudioHelper.CurrentProject;
	if (!string.IsNullOrWhiteSpace(SourceProject))
    {
		srcProject = VisualStudioHelper.GetProject(SourceProject);
    }

	string sourceNamespace = VisualStudioHelper.GetDefaultNamespace(srcProject);

	var manager = Manager.Create(Host, GenerationEnvironment);
	manager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using ServiceStack;
using ServiceStack.OrmLite;
using Tmpi.Pyrene.Infrastructure;
using <#= sourceNamespace #>;
using <#= sourceNamespace #>.Types;

namespace <#= fileNamespace #>
{
<#
	manager.EndBlock(); // end header

	var dic = new Dictionary<string, List<string>>();

    // get all class items from the code model
    var allClasses = VisualStudioHelper.CodeModel.GetAllCodeElementsOfType(srcProject.CodeModel.CodeElements, EnvDTE.vsCMElement.vsCMElementClass, false);
	allClasses = allClasses.OrderBy(c => c.Name).ToList();
	// iterate all classes
    foreach (EnvDTE.CodeClass codeClass in allClasses)
    {
		bool included = ClassFilterInclude == null || ClassFilterInclude.IsMatch(codeClass.Name);
		bool excluded = ClassFilterExclude != null && ClassFilterExclude.IsMatch(codeClass.Name);
		if (!included || excluded)
        {
			continue;
        }
		
		IEnumerable<EnvDTE.CodeClass> partialClasses = VisualStudioHelper.CodeModel.GetPartialClasses(codeClass);
		bool hasRouteAttr = partialClasses.SelectMany(c => c.Attributes.OfType<EnvDTE.CodeElement>()).Any(c => c.FullName == "ServiceStack.RouteAttribute");
		if (hasRouteAttr)
        {
			string entityName = null;

			var baseClass = VisualStudioHelper.CodeModel.GetBaseClass(codeClass);
			if (baseClass != null)
			{
				switch (baseClass.Name)
				{
					case "GetByIdRequestBase":
						entityName = codeClass.Name.Substring(3);
						break;
				
					case "DeleteByIdRequestBase":
						entityName = codeClass.Name.Substring(6);
						break;

					case "PatchByIdRequestBase":
						entityName = codeClass.Name.Substring(5);
						break;

					case "AutocompleteRequestBase":
						entityName = codeClass.Name.Substring(12);
						break;
				}
			}

			// get all interfaces implemented by this class
			var allInterfaces = VisualStudioHelper.CodeModel.GetAllImplementedInterfaces(codeClass);
			if (allInterfaces.Any(i => i.FullName == "ServiceStack.Model.IHasId<System.Int32>" || i.FullName == "ServiceStack.Model.IHasIntId"))
			{
				entityName = codeClass.Name;
			}

			if (!string.IsNullOrEmpty(entityName))
			{
				if (dic.Any(d => entityName.StartsWith(d.Key)))
				{
					var kvp = dic.Single(d => entityName.StartsWith(d.Key));
					kvp.Value.Add(codeClass.Name);
				}
				else
				{
					dic.Add(entityName, new List<string>(new[] { codeClass.Name } ));
				}
			}
        }
    } // end foreach

	var classDefinitionWords = new List<string>();
	classDefinitionWords.Add("public");
	if (MakeClassesPartial)
    {
		classDefinitionWords.Add("partial");
    }

	int CPT_MAX = 0;

	foreach (var kvp in dic)
	{
		var serviceClassName = kvp.Key + "Service";
		manager.StartNewFile(serviceClassName + ".generated.cs");
#>
	/// <summary>
	/// Service qui traite les requêtes sur l'entité <see cref="<#= kvp.Key #>" />.
	/// </summary>
	<#= string.Join(" ", classDefinitionWords) #> class <#= serviceClassName #> : Service
	{
<#
		foreach (string requestName in kvp.Value)
        {
			if (CPT_MAX >= 10)
			{
			continue; // limitation version démo de ServiceStack
			}

			if (requestName.StartsWith("Autocomplete"))
            {
				var entityName = requestName.Substring(12);
#>
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request">Requête à traiter.</param>
		/// <returns></returns>
		public List<string> Get(<#= requestName #> request)
		{
			if (string.IsNullOrWhiteSpace(request.Text))
			{
				return null;
			}

            var q = Db.From<<#= entityName #>>();
            if (request.Max > 0)
            {
                q = q.Limit(request.Max);
            }

            var lstCodObjet = Db.Column<string>(
                q.Where(x => x.CodObjet.Contains(request.Text)).Select(x => x.CodObjet)
                );
            var lstLibObjet = Db.Column<string>(
                q.Where(x => x.LibObjet.Contains(request.Text)).Select(x => x.LibObjet)
                );

            return lstCodObjet.Union(lstLibObjet).ToList();
		}

<#
            }
			else if (requestName.StartsWith("Get"))
            {
				var entityName = requestName.Substring(3);
#>
		/// <summary>
		/// Retourne l'entité <see cref="<#= entityName #>" /> spécifiée dans la requête.
		/// </summary>
		/// <param name="request">Requête à traiter.</param>
		/// <returns>Entité <see cref="<#= entityName #>" /> trouvée.</returns>
		/// <exception cref="HttpError">L'entité spécifiée est introuvable.</exception>
		public <#= entityName #> Get(<#= requestName #> request)
		{
			var entity = Db.SingleById<<#= entityName #>>(request.Id);
			if (entity == null)
			{
				throw HttpError.NotFound(
					string.Format(ErrorMessages.EntityByIdNotFound, nameof(<#= entityName #>), request.Id));
			}
			return entity;
		}

<#
            }
			else if (requestName.StartsWith("Delete"))
            {
				var entityName = requestName.Substring(6);
#>
		/// <summary>
		/// Supprime l'entité <see cref="<#= entityName #>" /> spécifiée dans la requête.
		/// </summary>
		/// <param name="request">Requête à traiter.</param>
		/// <exception cref="HttpError">L'entité spécifiée est introuvable.</exception>
		public void Delete(<#= requestName #> request)
		{
			int count = Db.DeleteById<<#= entityName #>>(request.Id);
			if (count == 0)
			{
				throw HttpError.NotFound(
					string.Format(ErrorMessages.EntityByIdNotFound, nameof(<#= entityName #>), request.Id));
			}
		}

<#
            }
			else if (requestName.StartsWith("Patch"))
            {
				var entityName = requestName.Substring(5);
#>
		/// <summary>
		/// Met à jour l'entité <see cref="<#= entityName #>" /> spécifiée dans la requête.
		/// </summary>
		/// <param name="request">Requête à traiter.</param>
		/// <exception cref="ArgumentNullException"></exception>
		/// <exception cref="HttpError">L'entité spécifiée est introuvable.</exception>
		public void Patch(<#= requestName #> request)
		{
			Debug.Assert(request.Fields != null);
			if (request.Fields == null)
			{
				throw new ArgumentNullException(nameof(request.Fields));
			}

			var entity = new <#= entityName #>();
			var updateFields = PatchHelper.PopulateFromPatch(entity, request.Fields);

			var updateExpr = Db.From<<#= entityName #>>().Update(updateFields).Where(x => x.Id == request.Id);
			int count = Db.UpdateOnly(entity, updateExpr);
			if (count == 0)
			{
				throw HttpError.NotFound(
					string.Format(ErrorMessages.EntityByIdNotFound, nameof(<#= entityName #>), request.Id));
			}
		}

<#
			}
			else if (requestName == kvp.Key)
            {
#>
		/// <summary>
		/// Ajoute l'entité <see cref="<#= requestName #>" /> spécifiée dans la requête.
		/// </summary>
		/// <param name="request">Requête à traiter.</param>
		/// <returns>Entité <see cref="<#= requestName #>" /> ajoutée.</returns>
		public <#= requestName #> Post(<#= requestName #> request)
		{
			var id = Db.Insert(request, selectIdentity: true);
			request.Id = (int)id;

			return request;
		}

		/// <summary>
		/// Remplace l'entité <see cref="<#= requestName #>" /> spécifiée dans la requête.
		/// </summary>
		/// <param name="request">Requête à traiter.</param>
		/// <exception cref="HttpError">L'entité spécifiée est introuvable.</exception>
		public void Put(<#= requestName #> request)
		{
			int count = Db.Update(request);
			if (count == 0)
			{
				throw HttpError.NotFound(
					string.Format(ErrorMessages.EntityByIdNotFound, nameof(<#= requestName #>), request.Id));
			}
		}

<#
            }

			CPT_MAX++;
        } // end foreach
#>
	}
<#
		manager.EndBlock();
    }

	manager.StartFooter();
#>
}
<#
	manager.EndBlock(); // end footer

	manager.Process(SplitIntoMultipleFiles);
#>
