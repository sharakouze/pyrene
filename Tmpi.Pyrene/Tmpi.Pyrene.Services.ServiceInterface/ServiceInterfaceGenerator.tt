<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="EnvDTE.dll" #>
<#@ assembly name="System.Core.dll" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Linq" #>
<#@ include file="$(SolutionDir)Shared\MultipleOutputHelper.ttinclude" #>
<#@ include file="$(SolutionDir)Shared\VisualStudioHelper.ttinclude" #>
<#
	/***** TODO *****
	- Trace des fields introuvables dans Get et Patch
	- Unicité
	****************/

	/*********************/
	/** CUSTOM SETTINGS **/
	/*********************/

	// Namespace des fichiers générés. Si vide DefaultNamespace du projet/répertoire courant.
	string Namespace = "";

	// Limite le traitement aux classes dans ce projet.
	string SourceProject = "Tmpi.Pyrene.Services.ServiceModel";
	
	// true pour générer des classes partial.
	bool MakeClassesPartial = true;

	// true pour générer chaque classe dans un fichier séparé.
	bool SplitIntoMultipleFiles = true;
    
    // true pour créer les validors de la ValidationFeature
    bool CreateValidators = true;

    // true pour rajouter .WithMessage() pour chaque RuleFor
    bool ValidatorsWithMessage = false;

	// RegExp pour filtrer globalement les classes traitées, null pour tout inclure et/ou ne rien exclure.
	Regex ClassFilterInclude = null;
	Regex ClassFilterExclude = null;

#>
<#
	// namespace
	string fileNamespace = Namespace;
	if (string.IsNullOrWhiteSpace(fileNamespace))
    {
		fileNamespace = VisualStudioHelper.CurrentFileNamespace;
	}

	// get a reference to the project of this t4 template
	Project srcProject = VisualStudioHelper.CurrentProject;
	if (!string.IsNullOrWhiteSpace(SourceProject))
    {
		srcProject = VisualStudioHelper.GetProject(SourceProject);
    }

	string sourceNamespace = VisualStudioHelper.GetDefaultNamespace(srcProject);

	Manager manager = Manager.Create(Host, GenerationEnvironment);
	manager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

<#
	manager.EndBlock(); // end header

	var dic = new Dictionary<string, List<CodeClass>>();

    // get all class items from the code model
    List<CodeClass> allClasses = VisualStudioHelper.CodeModel.GetAllCodeElementsOfType(srcProject.CodeModel.CodeElements, EnvDTE.vsCMElement.vsCMElementClass, false)
		.OfType<CodeClass>()
		.OrderBy(c => c.Name)
		.ToList();

    foreach (CodeClass codeClass in allClasses)
    {
		bool included = ClassFilterInclude == null || ClassFilterInclude.IsMatch(codeClass.Name);
		bool excluded = ClassFilterExclude != null && ClassFilterExclude.IsMatch(codeClass.Name);
		if (!included || excluded)
        {
			continue;
        }
		
		IEnumerable<CodeAttribute> allClassAttributes = VisualStudioHelper.CodeModel.GetAllClassAttributes(codeClass);
		
		bool hasRouteAttr = allClassAttributes.Any(attr => attr.FullName == "ServiceStack.RouteAttribute");
		if (hasRouteAttr)
		{
			string entityName = null;

            if (codeClass.Name.StartsWith("Get"))
            {
				entityName = codeClass.Name.Substring(3);
            }
            else if (codeClass.Name.StartsWith("Delete"))
            {
 				entityName = codeClass.Name.Substring(6);
            }
            else if (codeClass.Name.StartsWith("Patch"))
            {
                entityName = codeClass.Name.Substring(5);
            }
            else if (codeClass.Name.StartsWith("Autocomplete"))
            {
                entityName = codeClass.Name.Substring(12);
            }
            else if (codeClass.Name.StartsWith("Find"))
            {
                entityName = codeClass.Name.Substring(4);
            }
			else
			{
				entityName = codeClass.Name;
			}

			if (!string.IsNullOrEmpty(entityName))
			{
				if (dic.Any(d => entityName.StartsWith(d.Key)))
				{
					var kvp = dic.Single(d => entityName.StartsWith(d.Key));
					kvp.Value.Add(codeClass);
				}
				else
				{
					dic.Add(entityName, new List<EnvDTE.CodeClass>(new[] { codeClass } ));
				}
			}
        }
    } // end foreach

	foreach (var kvp in dic)
	{
		string serviceClassName = kvp.Key + "Service";
		manager.StartNewFile(serviceClassName + ".generated.cs");
#>
using System;
using System.Collections.Generic;
using System.Linq;
using ServiceStack;
using ServiceStack.OrmLite;
using <#= sourceNamespace #>;
using <#= sourceNamespace #>.Types;
using Tmpi.Pyrene.Infrastructure;

namespace <#= fileNamespace #>
{
	/// <summary>
	/// Service qui traite les requêtes sur les ressources <see cref="<#= kvp.Key #>" />.
	/// </summary>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= serviceClassName #> : Service
	{
<#
		foreach (CodeClass requestClass in kvp.Value)
        {
            string requestName = requestClass.Name;

			if (requestName.StartsWith("Autocomplete"))
            {
				var entityName = requestName.Substring(12);
#>
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request">Requête à traiter.</param>
		/// <returns></returns>
		public List<BasicEntity> Get(<#= requestName #> request)
		{
			if (string.IsNullOrWhiteSpace(request.Text))
			{
				return null;
			}

            var q = Db.From<<#= entityName #>>().Where(x => x.LibObjet.Contains(request.Text));
            if (request.Max > 0)
            {
                q = q.Limit(request.Max);
            }

            var items = Db.Select<BasicEntity>(q);
            return items;
		}

<#
            }
			else if (requestName.StartsWith("Get"))
            {
				var lst = GetRouteProperties(requestClass, "");

				var entityName = requestName.Substring(3);
#>
		/// <summary>
		/// Retourne la ressource <see cref="<#= entityName #>" /> spécifiée dans la requête.
		/// </summary>
		/// <param name="request">Requête à traiter.</param>
		/// <returns>Ressource <see cref="<#= entityName #>" /> trouvée.</returns>
		/// <exception cref="ArgumentException">La ressource ne contient pas tous les champs spécifiés.</exception>
		/// <exception cref="HttpError">La ressource spécifiée est introuvable.</exception>
		public <#= entityName #> Get(<#= requestName #> request)
		{
            if (!request.Fields.IsNullOrEmpty())
            {
                var errFields = ModelDefinitionHelper.GetUndefinedFields<<#= entityName #>>(request.Fields);
                if (errFields.Any())
                {
                    string str = string.Join(", ", errFields.Select(f => "'" + f + "'"));
                    throw new ArgumentException(
                        string.Format(ServicesErrorMessages.ResourceFieldsNotFound, nameof(<#= entityName #>), str));
                }
            }

<#
				string whereExpr = "x =>";
				foreach(CodeProperty property in lst)
                {
					whereExpr += string.Format(" x.{0} == request.{0}", property.Name);
                }
#>
            var q = Db.From<<#= entityName #>>().Where(<#= whereExpr #>).Select(request.Fields);

			var entity = Db.Single(q);
			if (entity == null)
			{
				throw HttpError.NotFound(
					string.Format(ServicesErrorMessages.ResourceByIdNotFound, nameof(<#= entityName #>), request.Id));
			}

			return entity;
		}

<#
            }
			else if (requestName.StartsWith("Delete"))
            {
				var entityName = requestName.Substring(6);
#>
		/// <summary>
		/// Supprime la ressource <see cref="<#= entityName #>" /> spécifiée dans la requête.
		/// </summary>
		/// <param name="request">Requête à traiter.</param>
		/// <exception cref="HttpError">La ressource spécifiée est introuvable.</exception>
		public void Delete(<#= requestName #> request)
		{
			int count = Db.DeleteById<<#= entityName #>>(request.Id);
			if (count == 0)
			{
				throw HttpError.NotFound(
					string.Format(ServicesErrorMessages.ResourceByIdNotFound, nameof(<#= entityName #>), request.Id));
			}
		}

<#
            }
			else if (requestName.StartsWith("Patch"))
            {
				var entityName = requestName.Substring(5);
#>
		/// <summary>
		/// Met à jour la ressource <see cref="<#= entityName #>" /> spécifiée dans la requête.
		/// </summary>
		/// <param name="request">Requête à traiter.</param>
		/// <exception cref="ArgumentNullException"></exception>
		/// <exception cref="ArgumentException">La ressource ne contient pas tous les champs spécifiés.</exception>
		/// <exception cref="HttpError">La ressource spécifiée est introuvable.</exception>
		public void Patch(<#= requestName #> request)
		{
			if (request.Fields.IsNullOrEmpty())
			{
				throw new ArgumentNullException(nameof(request.Fields));
			}

            var patchDic = request.Fields.ToDictionary(f => f.Field, f => f.Value);

            var errFields = ModelDefinitionHelper.GetUndefinedFields<<#= entityName #>>(patchDic.Keys);
            if (errFields.Any())
            {
                string str = string.Join(", ", errFields.Select(f => "'" + f + "'"));
                throw new ArgumentException(
                    string.Format(ServicesErrorMessages.ResourceFieldsNotFound, nameof(<#= entityName #>), str));
            }

			var entity = new <#= entityName #>();
			PatchHelper.PopulateFromPatch(entity, patchDic);

			var q = Db.From<<#= entityName #>>().Where(x => x.Id == request.Id).Update(patchDic.Keys);

			int count = Db.UpdateOnly(entity, q);
			if (count == 0)
			{
				throw HttpError.NotFound(
					string.Format(ServicesErrorMessages.ResourceByIdNotFound, nameof(<#= entityName #>), request.Id));
			}
		}

<#
			}
			else if (requestName.StartsWith("Find"))
            {
				var entityName = requestName.Substring(4);
#>
		/// <summary>
		/// Met à jour la ressource <see cref="<#= entityName #>" /> spécifiée dans la requête.
		/// </summary>
		/// <param name="request">Requête à traiter.</param>
		/// <exception cref="ArgumentNullException"></exception>
		/// <exception cref="HttpError">La ressource spécifiée est introuvable.</exception>
		public List<<#= entityName #>> Get(<#= requestName #> request)
		{
            return null;
		}

<#
			}
			else if (requestName == kvp.Key)
            {
#>
		/// <summary>
		/// Ajoute la ressource <see cref="<#= requestName #>" /> spécifiée dans la requête.
		/// </summary>
		/// <param name="request">Requête à traiter.</param>
		/// <returns>Ressource <see cref="<#= requestName #>" /> ajoutée.</returns>
		public <#= requestName #> Post(<#= requestName #> request)
		{
			var id = Db.Insert(request, selectIdentity: true);
			request.Id = (int)id;

			return request;
		}

		/// <summary>
		/// Remplace la ressource <see cref="<#= requestName #>" /> spécifiée dans la requête.
		/// </summary>
		/// <param name="request">Requête à traiter.</param>
		/// <exception cref="HttpError">La ressource spécifiée est introuvable.</exception>
		public void Put(<#= requestName #> request)
		{
			int count = Db.Update(request);
			if (count == 0)
			{
				throw HttpError.NotFound(
					string.Format(ServicesErrorMessages.ResourceByIdNotFound, nameof(<#= requestName #>), request.Id));
			}
		}

<#
            }
        } // end foreach
#>
	}
}
<#
		manager.EndBlock(); // end newfile

        if (CreateValidators)
        {
            foreach (EnvDTE.CodeClass requestClass in kvp.Value)
            {
                string requestName = requestClass.Name;

                if (requestName == kvp.Key)
                {
                    manager.StartNewFile(requestName + "Validator.generated.cs");
#>
using ServiceStack.FluentValidation;
using <#= sourceNamespace #>;
using <#= sourceNamespace #>.Types;

namespace <#= fileNamespace #>
{
    /// <summary>
    /// Validation pour la requête <see cref="<#= requestName #>"/>.
    /// </summary>
    public <#= MakeClassesPartial ? "partial " : "" #>class <#= requestName #>Validator : AbstractValidator<<#= requestName #>>
    {
        /// <summary>
        /// Initialise une nouvelle instance de la classe <see cref="<#= requestName #>Validator" />.
        /// </summary>
        public <#= requestName #>Validator()
        {
<#
                    var allPropsAttributes = VisualStudioHelper.CodeModel.GetAllPropertiesAttributes(requestClass);
                    foreach (var prop in allPropsAttributes)
                    {
                        var lstValidation = new List<string>();

                        if (prop.Value.Any(attr => attr.FullName == "ServiceStack.DataAnnotations.RequiredAttribute"))
                        {
                            if (prop.Key.Type.AsFullName == "System.String")
                            {
                                string str = ".NotEmpty()";
                                if (ValidatorsWithMessage)
                                {
                                    str += string.Format(".WithMessage(ValidationMessages.{0}_{1}_NotEmpty)", requestName, prop.Key.Name);
                                }
                                lstValidation.Add(str);
                            }
                        }
                        var strLengthAttr = prop.Value.FirstOrDefault(attr => attr.FullName == "ServiceStack.DataAnnotations.StringLengthAttribute");
                        if (strLengthAttr != null)
                        {
                            int min = 0;
                            int max = Convert.ToInt32(strLengthAttr.Value);
                            string str = string.Format(".Length({0}, {1})", min, max);
                            if (ValidatorsWithMessage)
                            {
                                str += string.Format(".WithMessage(ValidationMessages.{0}_{1}_Length, {2}, {3})", requestName, prop.Key.Name, min, max);
                            }
                            lstValidation.Add(str);
                        }

                        if (prop.Key.Name == "NumEmail")
                        {
                            lstValidation.Add(".EmailAddress()");
                        }

                        if (lstValidation.Any())
                        {
#>
            RuleFor(x => x.<#= prop.Key.Name #>)
<#
                            for (int i = 0; i < lstValidation.Count; i++)
                            {
#>
                <#= lstValidation[i] #><#= i == lstValidation.Count - 1 ? ";" : "" #>
<#
                            } // end foreach
                        } // end if
                    } // end foreach
#>

            SetRules();
        }
        
        /// <summary>
        /// Définit des règles de validation supplémentaires.
        /// </summary>
        partial void SetRules();
    }
}
<#
                    manager.EndBlock(); // end newfile
                }
            } // end foreach
        } // end if
    } // end forach

	manager.Process(SplitIntoMultipleFiles);
#>
<#+
private List<CodeProperty> GetRouteProperties(CodeClass codeClass, string verb)
{
	List<CodeProperty> properties = new List<CodeProperty>();

	IEnumerable<CodeAttribute> routeAttributes = VisualStudioHelper.CodeModel.GetAllClassAttributes(codeClass)
		.Where(attr => attr.FullName == "ServiceStack.RouteAttribute")
		.ToList();
	foreach (CodeAttribute attr in routeAttributes)
    {
		string[] parameters = attr.Value.Split(',');

		if (!string.IsNullOrEmpty(verb))
        {
			string paramVerbs = "";
			
			if (parameters.Length > 1)
			{
				paramVerbs = parameters[1];
			}
			else
			{
				paramVerbs = parameters.Where(s => s.Trim().StartsWith("Verbs =")).SingleOrDefault();
			}
			if (!string.IsNullOrEmpty(paramVerbs))
            {
				bool notFound = paramVerbs.IndexOf(verb, StringComparison.OrdinalIgnoreCase) == -1;
				if (notFound)
                {
					continue;
                }
            }
		}
		
		string paramPath = parameters[0].Trim();

		if (paramPath.StartsWith("\"") && paramPath.EndsWith("\""))
        {
			paramPath = paramPath.Remove(0, 1); // Supprime le premier "
			paramPath = paramPath.Remove(paramPath.Length - 1, 1); // Supprime le dernier "
        }

		List<string> lstPlaceholders = paramPath.Split('/').Where(s => s.StartsWith("{") && s.EndsWith("}")).ToList();
		IEnumerable<CodeProperty> props = VisualStudioHelper.CodeModel.GetAllProperties(codeClass);

		foreach (string ph in lstPlaceholders)
        {
			string propName = ph;
			propName = propName.Remove(0, 1); // Supprime le premier {
			propName = propName.Remove(propName.Length - 1, 1); // Supprime le dernier }

			var prop = props.Where(p => p.Name == propName).Single();
			properties.Add(prop);
        }
    }

	return properties;
}
#>