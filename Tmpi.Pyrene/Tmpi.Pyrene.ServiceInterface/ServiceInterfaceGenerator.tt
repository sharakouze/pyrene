<#@ template language="C#" hostspecific="true" debug="true" #>
<#@ output extension=".generated.cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="EnvDTE" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Linq" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\MultipleOutputHelper.ttinclude" once="true" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\VisualStudioHelper.ttinclude" once="true" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\ServiceInterfaceGenerator.ttinclude" once="true" #>
<#
	/***** TODO *****
	- Trace des fields introuvables dans Get et Patch
	- Unicité
	****************/

	/*********************/
	/** CUSTOM SETTINGS **/
	/*********************/

	// Namespace des fichiers générés. Si vide DefaultNamespace du projet/répertoire courant.
	string BaseNamespace = "";
	// {0} = BaseNamespace
    string NamespaceServices = "{0}";
    string NamespaceValidators = "{0}.Validators";

	// Limite le traitement aux classes dans ce projet.
	string SourceProject = "Tmpi.Pyrene.ServiceModel";
	
	// true pour générer des classes partial.
	bool MakeClassesPartial = true;

	// true pour générer chaque classe dans un fichier séparé.
	bool SplitIntoMultipleFiles = true;
	// Extension des fichiers générés
	string FileExtension = ".generated.cs";
	string FilePrefix = "ServiceInterface.";

	// tableau de numéros d'avertissement à désactiver ; null ou vide pour ignorer.
	int[] PragmaWarningDisable = new [] { 1591 };
    
    // true pour créer les validors de la ValidationFeature
    bool CreateValidators = true;

    // true pour rajouter .WithMessage() pour chaque RuleFor
    bool ValidatorsWithMessage = false;

	// RegExp pour filtrer globalement les classes traitées, null pour tout inclure et/ou ne rien exclure.
	Regex ClassFilterInclude = null;
	Regex ClassFilterExclude = null;

#>
<#
	var vsHelper = AutomationHelper.Create(this);

	// namespace
	if (string.IsNullOrWhiteSpace(BaseNamespace))
    {
		BaseNamespace = vsHelper.GetTemplateFileNamespace();
	}

	// get a reference to the project of this t4 template
	var srcProject = vsHelper.CurrentProject;
	if (!string.IsNullOrWhiteSpace(SourceProject))
    {
		srcProject = vsHelper.GetProject(SourceProject);
    }

	string sourceNamespace = vsHelper.GetDefaultNamespace(srcProject);

	var manager = Manager.Create(this);
	manager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
// Ce code a été généré par un outil.
//
// Les modifications apportées à ce fichier peuvent provoquer un comportement
// incorrect et seront perdues si le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

<#
	if (PragmaWarningDisable != null && PragmaWarningDisable.Any())
    {
		string strWarningList = string.Join(", ", PragmaWarningDisable.Select(n => n.ToString()));
#>
#pragma warning disable <#= strWarningList #>

<#
    }

	manager.EndBlock(); // end header

	var dicRequest = new Dictionary<string, List<RequestItem>>();

    // get all class items from the code model
    var allClasses = vsHelper.CodeModel.GetAllClasses(srcProject).OrderBy(c => c.Name).ToList();

    foreach (var codeClass in allClasses)
    {
		bool included = ClassFilterInclude == null || ClassFilterInclude.IsMatch(codeClass.Name);
		bool excluded = ClassFilterExclude != null && ClassFilterExclude.IsMatch(codeClass.Name);
		if (!included || excluded)
        {
			continue;
        }

		string pocoClassName = null;
        if (codeClass.Name.StartsWith("Get"))
        {
			pocoClassName = codeClass.Name.Substring(3);
        }
        else if (codeClass.Name.StartsWith("Delete"))
        {
 			pocoClassName = codeClass.Name.Substring(6);
        }
        else if (codeClass.Name.StartsWith("Patch"))
        {
            pocoClassName = codeClass.Name.Substring(5);
        }
        else if (codeClass.Name.StartsWith("Search"))
        {
			pocoClassName = codeClass.Name.Substring(6);
        }
        else if (codeClass.Name.StartsWith("Select"))
        {
			pocoClassName = codeClass.Name.Substring(6);
        }
		else
		{
			pocoClassName = codeClass.Name;
		}

		var lstRouteAttrs = vsHelper.CodeModel.GetAllClassAttributes(codeClass)
			.Where(attr => attr.FullName == "ServiceStack.RouteAttribute")
			.ToList();
		if (lstRouteAttrs.Any() && !string.IsNullOrEmpty(pocoClassName))
        {
			var items = dicRequest.Where(kvp => pocoClassName.StartsWith(kvp.Key)).Select(kvp => kvp.Value).SingleOrDefault();
			if (items == null)
			{
				items = new List<RequestItem>();
				dicRequest.Add(pocoClassName, items);
			}

			var item = new RequestItem();
			item.RequestClass = codeClass;
			item.PocoClass = allClasses.SingleOrDefault(c => c.Name == pocoClassName);
			foreach (var routeAttr in lstRouteAttrs)
			{
				item.LstRouteParts.Add(GetRouteParts(routeAttr));
			}
			items.Add(item);
        }
    } // end foreach

	var sig = new ServiceInterfaceGenerator(this);
	sig.MakeClassesPartial = MakeClassesPartial;

	foreach (var kvp in dicRequest)
	{
		string serviceNamespace = string.Format(NamespaceServices, BaseNamespace);
		string serviceClassName = kvp.Key + "Service";
		string serviceFileName = ServiceInterfaceUtils.GetGeneratedFilename(serviceClassName, serviceNamespace, BaseNamespace);
		manager.StartNewFile(FilePrefix + serviceFileName + FileExtension);

		sig.WriteService(kvp.Key, sourceNamespace, serviceNamespace, kvp.Value);

		manager.EndBlock(); // end newfile

        if (CreateValidators)
        {
			string validatorNamespace = string.Format(NamespaceValidators, BaseNamespace);
			string validatorClassName = kvp.Key;
			string validatorFileName = ServiceInterfaceUtils.GetGeneratedFilename(validatorClassName, validatorNamespace, BaseNamespace);
			manager.StartNewFile(FilePrefix + validatorFileName + FileExtension);

			var validatorRequests = kvp.Value.Where(item => item.RequestClass == item.PocoClass);
			sig.WriteValidator(sourceNamespace, validatorNamespace, validatorRequests, ValidatorsWithMessage);

			manager.EndBlock(); // end newfile
        }
    } // end foreach

	manager.Process(SplitIntoMultipleFiles);
#>
<#+
public static class ServiceInterfaceUtils
{
	public static string GetGeneratedFilename(string filename, string fileNamespace, string baseNamespace)
	{
		if (fileNamespace == baseNamespace)
		{
			return filename;
		}

		string str = fileNamespace.Replace(baseNamespace, "");
		if (str.StartsWith("."))
		{
			str = str.Remove(0, 1);
		}
		if (!str.EndsWith("."))
		{
			str = str + ".";
		}
		return str + filename;
	}
}
#>