<#@ template language="C#" hostspecific="true" debug="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Configuration" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Configuration" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Linq" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\MultipleOutputHelper.ttinclude" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\SqlSchemaReader.ttinclude" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\Config.ttinclude" #>
<#
	/***** TODO *****
	- DefaultAttribute
    - Commentaires sur les [References] ?
	- Possibilité d'avoir 0 PKey ?
	- Namespace par rapport au schéma
	****************/

	/*********************/
	/** CUSTOM SETTINGS **/
	/*********************/

	// schema a extraire ou vide pour tous les schémas
	string SchemaName = "";

    // Namespace des fichiers générés.
	string BaseNamespace = "Tmpi.Pyrene.ServiceModel";
	// {0} = BaseNamespace
    string NamespacePocos = "{0}.Types";
    string NamespaceMessages = "{0}.Messages";

    // true pour générer des classes partial.
    bool MakeClassesPartial = true;

    // true pour générer des propriétés virtual.
    bool MakePocoPropertiesVirtual = false;
    bool MakeMessagePropertiesVirtual = false;

    // true pour générer chaque classe dans un fichier séparé.
    bool SplitIntoMultipleFiles = true;
	// Extension des fichiers générés
	string FileExtension = ".generated.cs";

    // if true: Changes the primary key property name to Id.
    bool UseIdAsPK = false;

    // if true: Adds explicit '[Schema]' attribute.
    bool UseSchemaAttribute = true;

    // if true: Adds References(typeof(ReferenceTableType)) to FKs.
    bool IncludeReferences = true;

    // true: Ajoute [Index] et [CompositeIndex].
    bool IncludeIndices = true;

    // Ajoute les interfaces IAuditable, etc...
    bool AddCustomInterfaces = true;

    // Ajoute des propriétés avec l'attribut [Reference] pour les tables enfants ou les FK
    bool AddChildReferences = false;
    bool AddFKeyReferences = true;

    // Ajoute [ApiMember], [ApiAllowableValues]...
    bool AddApiAttributes = true;

    // true pour ajouter l'attribut [Route(...)] sur les classes générées.
    bool AddRouteAttributes = true;

    // true pour transformer la route de l'entité, ex: GenFournContact de '/GenFournContact/' en '/GenFourn/{xxx}/Contact/'.
    bool TransformRoutePath = true;

    // Filtre globalement les messages générés.
	Regex MsgTableFilterExclude = null;

    // Filtre les messages générés par type de message.
    Regex PostTableFilterExclude = null;
	Regex GetTableFilterExclude = null;
	Regex DeleteTableFilterExclude = null;
	Regex PatchTableFilterExclude = null;
	Regex SearchTableFilterExclude = null;
	Regex SelectTableFilterExclude = null;

	// Contient tous les enums par colonnes
	Dictionary<string, string> allEnums = new Dictionary<string, string>
    {
        { "Gen.Compteur.TypCompteur", "TypCompteur" },
        { "Gen.Compteur.TypPeriodicite", "TypPeriodicite" },
        { "Gen.Mandat.TypMandat", "TypMandat" },
        { "Gen.Personne.TypCivilite", "TypCivilite" },
        { "Gen.Fourn.TypModeReglement", "TypModeReglement" },
        { "Gen.FournContact.TypCivilite", "TypCivilite" },
    };

    // Si non null, méthode appliquée sur la collection des tables
    Action<Tables> TweakSchema = (tables) =>
    {	
		foreach (var table in tables)
        {
			string stdColFormat = GetStandardColumnFormat(table);
			SetColumnsDescription(table, stdColFormat);
        }

		tables.RemoveAll(t => t.Name == "__RefactorLog");

		foreach (var kvp in allEnums)
		{
			tables.ChangePropertyType(kvp.Key, kvp.Value);
		}
    };

#>
<#
    var manager = Manager.Create(Host, GenerationEnvironment);
    manager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
// Ce code a été généré par un outil.
//
// Les modifications apportées à ce fichier peuvent provoquer un comportement
// incorrect et seront perdues si le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable 1591

using System;
using System.Collections.Generic;
using System.Net;
using System.Runtime.Serialization;
using ServiceStack;
using ServiceStack.DataAnnotations;
using ServiceStack.Model;
<#
	manager.EndBlock(); // end header
    
    // Read schema
    var allTables = LoadTables(ConnectionString, SchemaName, false);
    if (TweakSchema != null)
    {
        TweakSchema(allTables);
    }

	// Test doublons
	var lstDuplicate = allTables.GroupBy(t => t.ClassName).Where(grp => grp.Count() > 1).Select(grp => grp.Key).ToList();
	if (lstDuplicate.Any())
    {
		string errorMsg = string.Format("Impossible de générer le modèle car des noms de tables sont en double : {0}",
			string.Join(", ", lstDuplicate));
		Error(errorMsg);
		
#>
// <#= errorMsg #>
<#
		allTables.Clear();
    }

    foreach (var table in allTables)
    {
	    bool msgExcluded = MsgTableFilterExclude != null && MsgTableFilterExclude.IsMatch(table.ClassName);

		/****************/
		/** BEGIN POCO **/
		/****************/

		string pocoNamespace = string.Format(NamespacePocos, BaseNamespace);
		string pocoFileName = GetGeneratedFilename(table.ClassName, pocoNamespace, BaseNamespace);
        manager.StartNewFile(pocoFileName + FileExtension);

#>

namespace <#= pocoNamespace #>
{
<#
        var lstInterfaces = new List<string>();

		if (table.PrimaryKey == null)
        {
			string errorMsg = string.Format("[{0}].[{1}] : La table est ignorée car elle n'a pas de clé primaire.",
				table.Schema, table.Name);
			Error(errorMsg);
#>
	// <#= errorMsg #>
<#
			continue;
        }
        else
        {
			if (table.PrimaryKey.PKeyColumns.Count > 1)
            {
				string errorMsg = string.Format("[{0}].[{1}].[{2}] : OrmLite ne supporte pas les clés primaires composites ; la table est ignorée.",
					table.Schema, table.Name, table.PrimaryKey.Name);
				Error(errorMsg);
#>
	// <#= errorMsg #>
<#
				continue;
            }

			var pkCol = table.PrimaryKey.PKeyColumns.Single();
            if (UseIdAsPK)
            {
                pkCol.PropertyName = "Id";
            }
            if (pkCol.PropertyName == "Id")
            {
                lstInterfaces.Add("IHasId<" + pkCol.PropertyType + ">");
            }
        }
        if (AddCustomInterfaces)
        {
            if (table.Columns.Any(c => c.PropertyName == "DatCreation" && c.ProperPropertyType == "DateTime") &&
                table.Columns.Any(c => c.PropertyName == "DatEdition" && c.ProperPropertyType == "DateTime?") &&
				table.Columns.Any(c => c.PropertyName == "CleCreateur" && c.ProperPropertyType == "int") &&
				table.Columns.Any(c => c.PropertyName == "CleEditeur" && c.ProperPropertyType == "int?"))
            {
                lstInterfaces.Add("IAuditable");
            }
        }

        if (table.ClassName != table.Name)
        {
#>
	[Alias("<#= table.Name #>")]
<#
        }
		
        if (UseSchemaAttribute && !string.IsNullOrEmpty(table.Schema) && table.Schema != "dbo")
        {
#>
	[Schema("<#= table.Schema #>")]
<#
        }
		
        if (IncludeIndices)
        {
			var compositeIdx = table.Indices.Where(i => i.IndexColumns.Count > 1);
            foreach (var idx in compositeIdx)
            {
				var q = idx.IndexColumns
					.Select(c => (c.Name == c.PropertyName) ? string.Format("nameof({0})", c.PropertyName) : string.Format("\"{0}\"", c.Name));
#>
	[CompositeIndex(<#= idx.IsUnique ? "true, " : "" #><#= string.Join(", ", q) #>)]
<#
            }
        }

		var lstPlaceholderCols = GetRouteColumns(table, TransformRoutePath);

		string entityName = table.ClassName; // GetEntityName(lstPlaceholderCols);

        if (!msgExcluded && AddRouteAttributes)
        {
			bool postExcluded = PostTableFilterExclude != null && PostTableFilterExclude.IsMatch(table.ClassName);
            if (!postExcluded)
            {
				string strRoute = GetStrRoutePath(lstPlaceholderCols, false, false);
#>
	[Route("<#= strRoute #>", HttpVerbs.Post, Summary = "<#= string.Format("Ajoute ou remplace une entité {0} à partir de son id", entityName) #>", Notes = SwaggerDescriptions.UpsertRequestNotes)]
<#
            }

            if (AddApiAttributes)
            {
				string entityNotUniqueResp = string.Format("L'entité {0} spécifiée est un doublon", entityName);
#>
	[ApiResponse(HttpStatusCode.Conflict, "<#= entityNotUniqueResp #>")]
<#
            }
        }

		var pocoInterfaces = new List<string>();
		if (!msgExcluded)
        {
			pocoInterfaces.Add("IReturn<" + table.ClassName + ">");
			pocoInterfaces.Add("IPost");
        }
		pocoInterfaces.AddRange(lstInterfaces);
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= table.ClassName #><#= pocoInterfaces.Any() ? " : " + string.Join(", ", pocoInterfaces) : "" #>
	{
<#
        foreach (var col in table.Columns)
        {
            if (!string.IsNullOrWhiteSpace(col.Description))
            {
#>
		/// <summary>
		/// <#= FormatXmlDoc(col.Description) #>
		/// </summary>
<#
			}

			var colFkey = table.ForeignKeys.FirstOrDefault(f => f.FromColumns.Contains(col));
			
			var remarks = new List<string>();
			if (col.IsPKey)
            {
				if (col.IsAutoIncrement)
                {
					remarks.Add("Clé primaire auto-incrémentée.");
                }
				else
                {
					remarks.Add("Clé primaire.");
                }
            }
			if (colFkey != null)
            {
				var refCol = colFkey.ReferencedColumns.First();
				remarks.Add(string.Format("Référence <see cref=\"{0}.{1}\"/>.", colFkey.ReferencedTable.ClassName, refCol.PropertyName));
            }

			if (remarks.Any())
            {
#>
		/// <remarks>
<#
				foreach (string str in remarks)
                {
#>
		/// <#= FormatXmlDoc(str) #>
<#
                }
#>
		/// </remarks>
<#
            }

			if (col.Name != col.PropertyName)
			{
#>
		[Alias("<#= col.Name #>")]
<#
			}

			if (col.PropertyType == "string" && col.Size > 0)
			{   
#>
		[StringLength(<#= col.Size #>)]
<#
            }
            else if (col.PropertyType == "decimal" && col.Precision > 0)
            {
#>
		[DecimalLength(<#= col.Precision #>, <#= col.Scale #>)]
<#
            }

            if (col.IsAutoIncrement)
            {
#>
		[AutoIncrement]
<#
            }

            if (col.IsComputed)
            {
#>
		[Compute]        
<#
            }

            if (IncludeReferences)
            {
                if (colFkey != null)
                {
                    if (string.IsNullOrEmpty(colFkey.DeleteRule))
                    {
#>
		[References(typeof(<#= colFkey.ReferencedTable.ClassName #>))]
<#
                    }
                    else
                    {
#>
		[ForeignKey(typeof(<#= colFkey.ReferencedTable.ClassName #>), OnDelete = "<#= colFkey.DeleteRule #>")]
<#
                    }
                }
            }

            if (col.IsNullable == false && col.IsAutoIncrement == false)
            {
#>
		[Required]
<#
            }

            if (IncludeIndices)
            {
				var index = table.Indices.Where(idx => idx.IndexColumns.Count == 1 && idx.IndexColumns.Contains(col)).FirstOrDefault();
                if (index != null)
                {
#>
		[Index<#= index.IsUnique ? "(true)" : "" #>]
<#
                }
            }

            if (col.IsPKey && (col.PropertyName != "Id"))
            {
#>
		[PrimaryKey]
<#
            }

			if (AddApiAttributes)
            {
				var dicApiMemberProps = GetApiMemberProps(col, allEnums.Values, lstInterfaces);
				if (dicApiMemberProps != null)
                {
					if (lstPlaceholderCols.Any(c => c.PropertyName == col.PropertyName))
					{
						if (!col.IsPKey || col.IsFKey)
                        {
							dicApiMemberProps.Add("ParameterType", "SwaggerParamTypes.Path");
                        }
					}
#>
		[ApiMember(<#= string.Join(", ", dicApiMemberProps.Select(kvp => kvp.Key + " = " + kvp.Value)) #>)]
<#
                }

                if (allEnums.Values.Contains(col.PropertyType))
                {
#>
		[ApiAllowableValues(nameof(<#= col.PropertyName #>), typeof(<#= col.PropertyType #>))]
<#
                }

            }
#>
		public <#= MakePocoPropertiesVirtual ? "virtual " : "" #><#= col.ProperPropertyType #> <#= col.PropertyName #> { get; set; }

<#
			if (AddFKeyReferences && IncludeReferences)
            {
				if (colFkey != null)
                {
					var refCol = colFkey.ReferencedColumns.First();

					string format = col.PropertyName.Replace(refCol.PropertyName, "{0}");
					string propName = string.Format(format, colFkey.ReferencedTable.ClassName);
#>
		/// <summary>
		/// <#= FormatXmlDoc("Entité référencée par <see cref=\"" + col.PropertyName + "\"/>.") #>
		/// </summary>
		[Reference]
		public <#= MakePocoPropertiesVirtual ? "virtual " : "" #><#= colFkey.ReferencedTable.ClassName #> <#= propName #> { get; set; }

<#

                }
            }
        } // end foreach (col)

        if (AddChildReferences)
        {
           var q = from tbl in allTables
					where tbl.Name.StartsWith(table.Name)
					from fk in tbl.ForeignKeys
					where fk.ReferencedTable == table
					let fkCol = fk.FromColumns.Single()
					let fkIsPK = tbl.PrimaryKey != null && tbl.PrimaryKey.PKeyColumns.Contains(fkCol)
					let fkIsUnique = tbl.Indices.Any(idx => idx.IsUnique && idx.IndexColumns.Count == 1 && idx.IndexColumns.Contains(fkCol))
					select new
					{
						Table = tbl,
						IsUnique = fkIsPK || fkIsUnique
					};
            foreach (var obj in q)
            {
                string propType = obj.Table.ClassName;
                string propName = "";
				if (obj.Table.ClassName == table.ClassName)
                {
					propName = table.ClassName;
                }
				else
                {
					propName = obj.Table.ClassName.Replace(table.ClassName, "");
                }
                if (!obj.IsUnique)
                {
                    propType = "List<" + propType + ">";
                    propName = "Lst" + propName;
                }
#>
		[Reference]
		public <#= MakePocoPropertiesVirtual ? "virtual " : "" #><#= propType #> <#= propName #> { get; set; }

<#
            }
        }
#>
	}
}
<#
		manager.EndBlock(); // end newfile (poco)

		if (msgExcluded)
        {
			continue;
        }

		string msgNamespace = string.Format(NamespaceMessages, BaseNamespace);
		string msgFileName = GetGeneratedFilename(table.ClassName, msgNamespace, BaseNamespace);
		manager.StartNewFile(msgFileName + FileExtension);

		if (pocoNamespace != msgNamespace)
        {
#>
using <#= pocoNamespace #>;
<#
		}
#>

namespace <#= msgNamespace #>
{
<#
		/******************/
		/** BEGIN SELECT **/
		/******************/

		bool selectExcluded = SelectTableFilterExclude != null && SelectTableFilterExclude.IsMatch(table.ClassName);
		if (!selectExcluded)
		{
			string selectTableClassName = "Select" + table.ClassName;
			string selectTableClassDescription = "Retourne une collection des entités {0}";
			string fieldsPropDescription = "Champs à retourner, ou null pour retourner tous les champs";
			string skipPropDescription = "Nombre d'éléments à ignorer avant de retourner les éléments restants";
			string takePropDescription = "Nombre d'éléments à retourner";
			string sortPropDescription = "Ordre de tri";

#>
	/// <summary>
	/// <#= FormatXmlDoc(selectTableClassDescription, entityName) #>
	/// </summary>
<#
            if (AddRouteAttributes)
            {
				string strRoute = GetStrRoutePath(lstPlaceholderCols, false, false);
#>
	[Route("<#= strRoute #>", HttpVerbs.Get, Summary = "<#= string.Format(selectTableClassDescription, entityName) #>", Notes = SwaggerDescriptions.SelectRequestNotes)]
<#
			    if (AddApiAttributes)
                {
					string entityNotFoundResp = string.Format("L'entité {0} spécifiée est introuvable", entityName);
#>
	[ApiResponse(HttpStatusCode.NotFound, "<#= entityNotFoundResp #>")]
<#
                }
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= selectTableClassName #> : IReturn<<#= selectTableClassName #>Response>, IGet, IPagination
	{
<#
			var lastCol = lstPlaceholderCols.LastOrDefault();
            foreach (var phCol in lstPlaceholderCols)
            {
				if (lastCol != null && lastCol.IsPKey && lastCol == phCol)
				{
					continue; // on ne prend que les colonnes foreign key
				}
				var newCol = phCol.Clone();
				var refCol = table.Columns.First(c => c.PropertyName == phCol.PropertyName);
				if (refCol != null)
                {
					newCol.Description = refCol.Description;
                }

				if (!string.IsNullOrWhiteSpace(newCol.Description))
				{
#>
		/// <summary>
		/// <#= FormatXmlDoc(newCol.Description) #>
		/// </summary>
<#
				}
				if (AddApiAttributes)
				{
					var dicApiMemberProps = GetApiMemberProps(newCol, allEnums.Values, lstInterfaces);
					if (dicApiMemberProps != null)
					{
						dicApiMemberProps.Add("ParameterType", "SwaggerParamTypes.Path");
#>
		[ApiMember(<#= string.Join(", ", dicApiMemberProps.Select(kvp => kvp.Key + " = " + kvp.Value)) #>)]
<#
					}
				}
#>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #><#= newCol.ProperPropertyType #> <#= newCol.PropertyName #> { get; set; }

<#
            }

#>
		/// <summary>
		/// <#= FormatXmlDoc(fieldsPropDescription) #>
		/// </summary>
		/// <example>
		/// CleCompteur,CodCompteur,LibCompteur,EstActif,Service(CodService,LibService)
		/// </example>
<#
			if (AddApiAttributes)
            {
#>
		[ApiMember(Description = "<#= fieldsPropDescription #>", DataType = SwaggerDataTypes.String)]
<#
            }
#>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>string Fields { get; set; }

		/// <summary>
		/// <#= FormatXmlDoc(skipPropDescription) #>
		/// </summary>
<#
			if (AddApiAttributes)
            {
#>
		[ApiMember(Description = "<#= skipPropDescription #>", DataType = SwaggerDataTypes.Int)]
<#
            }
#>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>int? Skip { get; set; }

		/// <summary>
		/// <#= FormatXmlDoc(takePropDescription) #>
		/// </summary>
<#
			if (AddApiAttributes)
            {
#>
		[ApiMember(Description = "<#= takePropDescription #>", DataType = SwaggerDataTypes.Int)]
<#
            }
#>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>int? Take { get; set; }

		/// <summary>
		/// <#= FormatXmlDoc(sortPropDescription) #>
		/// </summary>
		/// <remarks>
		/// En préfixant le nom du champ avec le caractère moins (-) le tri sera descendant.
		/// Par défaut le tri est ascendant.
		/// </remarks>
<#
			if (AddApiAttributes)
            {
#>
		[ApiMember(Description = "<#= sortPropDescription #>", DataType = SwaggerDataTypes.ArrayOfString)]
<#
            }
#>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>string[] Sort { get; set; }
	}

	/// <summary>
	/// <#= FormatXmlDoc("Réponse à la requête {0}.", selectTableClassName) #>
	/// </summary>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= selectTableClassName #>Response
	{
		/// <summary>
		/// <#= FormatXmlDoc("Erreur éventuelle.") #>
		/// </summary>
		public ResponseStatus ResponseStatus { get; set; }

		/// <summary>
		/// <#= FormatXmlDoc("Nombre total d'éléments disponibles.") #>
		/// </summary>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>int TotalCount { get; set; }

		/// <summary>
		/// <#= FormatXmlDoc("Collection des entités {0}.", entityName) #>
		/// </summary>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>List<<#= table.ClassName #>> Results { get; set; }
	}

<#
        }

		/********************/
		/** BEGIN GET BYID **/
		/********************/

		bool getExcluded = GetTableFilterExclude != null && GetTableFilterExclude.IsMatch(table.ClassName);
		if (!getExcluded)
		{
			string getTableClassName = "Get" + table.ClassName;
			string getTableClassDescription = "Retourne une entité {0} à partir de son id";
			string fieldsPropDescription = "Champs à retourner, ou null pour retourner tous les champs";
#>
	/// <summary>
	/// <#= FormatXmlDoc(getTableClassDescription, entityName) #>
	/// </summary>
<#
            if (AddRouteAttributes)
            {
				string strRoute = GetStrRoutePath(lstPlaceholderCols);
#>
	[Route("<#= strRoute #>", HttpVerbs.Get, Summary = "<#= string.Format(getTableClassDescription, entityName) #>", Notes = SwaggerDescriptions.GetByIdRequestNotes)]
<#
			    if (AddApiAttributes)
                {
					string entityFieldsNotFoundResp = string.Format("L'entité {0} ne contient pas tous les champs demandés", entityName);
					string entityNotFoundResp = string.Format("L'entité {0} spécifiée est introuvable", entityName);
#>
	[ApiResponse(HttpStatusCode.BadRequest, "<#= entityFieldsNotFoundResp #>")]
	[ApiResponse(HttpStatusCode.NotFound, "<#= entityNotFoundResp #>")]
<#
                }
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= getTableClassName #> : IReturn<<#= table.ClassName #>>, IGet
	{
<#
		var lastCol = lstPlaceholderCols.LastOrDefault();
		foreach (var phCol in lstPlaceholderCols)
		{
			if (lastCol != null && lastCol.IsPKey && lastCol != phCol)
            {
				continue; // on ignore les colonnes qui ne sont pas la PK de l'entité
            }
			var newCol = phCol.Clone();
			newCol.Description = "Identifiant unique de l'entité à retourner";

			if (!string.IsNullOrWhiteSpace(newCol.Description))
            {
#>
		/// <summary>
		/// <#= FormatXmlDoc(newCol.Description) #>
		/// </summary>
<#
            }
			if (AddApiAttributes)
            {
				var dicApiMemberProps = GetApiMemberProps(newCol, allEnums.Values, lstInterfaces);
				if (dicApiMemberProps != null)
                {
					dicApiMemberProps.Add("ParameterType", "SwaggerParamTypes.Path");
#>
		[ApiMember(<#= string.Join(", ", dicApiMemberProps.Select(kvp => kvp.Key + " = " + kvp.Value)) #>)]
<#
                }
            }
#>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #><#= newCol.ProperPropertyType #> <#= newCol.PropertyName #> { get; set; }

<#
		}
#>
		/// <summary>
		/// <#= FormatXmlDoc(fieldsPropDescription) #>
		/// </summary>
<#
			    if (AddApiAttributes)
                {
#>
		[ApiMember(Description = "<#= fieldsPropDescription #>", DataType = SwaggerDataTypes.String)]
<#
                }
#>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>string Fields { get; set; }
	}

<#
		}

		/***********************/
		/** BEGIN DELETE BYID **/
		/***********************/

		bool deleteExcluded = DeleteTableFilterExclude != null && DeleteTableFilterExclude.IsMatch(table.ClassName);
		if (!deleteExcluded)
		{
			string deleteTableClassName = "Delete" + table.ClassName;
			string deleteTableClassDescription = "Supprime une entité {0} à partir de son id";
#>
	/// <summary>
	/// <#= FormatXmlDoc(deleteTableClassDescription, entityName) #>
	/// </summary>
<#
            if (AddRouteAttributes)
            {
				string strRoute = GetStrRoutePath(lstPlaceholderCols);
#>
	[Route("<#= strRoute #>", HttpVerbs.Delete, Summary = "<#= string.Format(deleteTableClassDescription, entityName) #>", Notes = SwaggerDescriptions.DeleteByIdRequestNotes)]
<#
			    if (AddApiAttributes)
                {
					string entityNotFoundResp = string.Format("L'entité {0} spécifiée est introuvable", entityName);
#>
	[ApiResponse(HttpStatusCode.NotFound, "<#= entityNotFoundResp #>")]
<#
                }
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= deleteTableClassName #> : IReturnVoid, IDelete
	{
<#
		var lastCol = lstPlaceholderCols.LastOrDefault();
		foreach (var phCol in lstPlaceholderCols)
		{
			if (lastCol != null && lastCol.IsPKey && lastCol != phCol)
            {
				continue; // on ignore les colonnes qui ne sont pas la PK de l'entité
            }
			var newCol = phCol.Clone();
			newCol.IsNullable = false;
			newCol.Description = "Identifiant unique de l'entité à supprimer";

			if (!string.IsNullOrWhiteSpace(newCol.Description))
            {
#>
		/// <summary>
		/// <#= FormatXmlDoc(newCol.Description) #>
		/// </summary>
<#
            }
			if (AddApiAttributes)
            {
				var dicApiMemberProps = GetApiMemberProps(newCol, allEnums.Values, lstInterfaces);
				if (dicApiMemberProps != null)
                {
					dicApiMemberProps.Add("ParameterType", "SwaggerParamTypes.Path");
#>
		[ApiMember(<#= string.Join(", ", dicApiMemberProps.Select(kvp => kvp.Key + " = " + kvp.Value)) #>)]
<#
                }
            }
#>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #><#= newCol.ProperPropertyType #> <#= newCol.PropertyName #> { get; set; }

<#
		}
#>
	}

<#
		}

		/**********************/
		/** BEGIN PATCH BYID **/
		/**********************/

		bool patchExcluded = PatchTableFilterExclude != null && PatchTableFilterExclude.IsMatch(table.ClassName);
		if (!patchExcluded)
		{
			string patchTableClassName = "Patch" + table.ClassName;
			string patchTableClassDescription = "Modifie partiellement une entité {0} à partir de son id";
			string fieldsPropDescription = "Liste des modifications à appliquer";
#>
	/// <summary>
	/// <#= FormatXmlDoc(patchTableClassDescription, entityName) #>
	/// </summary>
<#
            if (AddRouteAttributes)
            {
				string strRoute = GetStrRoutePath(lstPlaceholderCols);
#>
	[Route("<#= strRoute #>", HttpVerbs.Patch, Summary = "<#= string.Format(patchTableClassDescription, entityName) #>", Notes = SwaggerDescriptions.PatchByIdRequestNotes)]
<#
			    if (AddApiAttributes)
                {
					string entityFieldsNotFoundResp = string.Format("L'entité {0} ne contient pas tous les champs demandés", entityName);
					string entityNotFoundResp = string.Format("L'entité {0} spécifiée est introuvable", entityName);
					string entityNotUniqueResp = string.Format("L'entité {0} spécifiée est un doublon", entityName);
#>
	[ApiResponse(HttpStatusCode.BadRequest, "<#= entityFieldsNotFoundResp #>")]
	[ApiResponse(HttpStatusCode.NotFound, "<#= entityNotFoundResp #>")]
	[ApiResponse(HttpStatusCode.Conflict, "<#= entityNotUniqueResp #>")]
<#
                }
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= patchTableClassName #> : IReturnVoid, IPatch
	{
<#
		var lastCol = lstPlaceholderCols.LastOrDefault();
		foreach (var phCol in lstPlaceholderCols)
		{
			if (lastCol != null && lastCol.IsPKey && lastCol != phCol)
            {
				continue; // on ignore les colonnes qui ne sont pas la PK de l'entité
            }
			var newCol = phCol.Clone();
			newCol.Description = "Identifiant unique de l'entité à modifier";

			if (!string.IsNullOrWhiteSpace(newCol.Description))
            {
#>
		/// <summary>
		/// <#= FormatXmlDoc(newCol.Description) #>
		/// </summary>
<#
            }
			if (AddApiAttributes)
            {
				var dicApiMemberProps = GetApiMemberProps(newCol, allEnums.Values, lstInterfaces);
				if (dicApiMemberProps != null)
                {
					dicApiMemberProps.Add("ParameterType", "SwaggerParamTypes.Path");
#>
		[ApiMember(<#= string.Join(", ", dicApiMemberProps.Select(kvp => kvp.Key + " = " + kvp.Value)) #>)]
<#
                }
            }
#>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #><#= newCol.ProperPropertyType #> <#= newCol.PropertyName #> { get; set; }

<#
		}
#>
		/// <summary>
		/// <#= FormatXmlDoc(fieldsPropDescription) #>
		/// </summary>
<#
			    if (AddApiAttributes)
                {
#>
		[ApiMember(Description = "<#= fieldsPropDescription #>", DataType = "Array[" + nameof(Patch) + "]", IsRequired = true, ParameterType = SwaggerParamTypes.Form)]
<#
                }
#>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>Patch[] Operations { get; set; }
	}

<#
		}

		string stdColFormat = GetStandardColumnFormat(table);
		bool hasPK = (table.PrimaryKey != null);
		bool hasCodObjet = table.Columns.Any(c => c.PropertyType == "string" && c.PropertyName == string.Format(stdColFormat, "Cod"));
		bool hasLibObjet = table.Columns.Any(c => c.PropertyType == "string" && c.PropertyName == string.Format(stdColFormat, "Lib"));
		bool hasEstActif = table.Columns.Any(c => c.PropertyType == "bool" && c.PropertyName == "EstActif");

		if (hasPK && hasCodObjet && hasLibObjet && hasEstActif)
        {
			/************************/
			/** BEGIN AUTOCOMPLETE **/
			/************************/

			bool searchExcluded = SearchTableFilterExclude != null && SearchTableFilterExclude.IsMatch(table.ClassName);
			if (!searchExcluded)
			{
				string searchClassName = "Search" + table.ClassName;
				string searchDescription = "Retourne le résultat d'une recherche sur les entités {0}";
				string textPropDescription = "Texte à rechercher";
				string maxPropDescription = "Nombre maximum de résultats à retourner";
#>
	/// <summary>
	/// <#= FormatXmlDoc(searchDescription, entityName) #>
	/// </summary>
<#
			if (AddRouteAttributes)
            {
				string strRouteBase = GetStrRoutePath(lstPlaceholderCols, false);
#>
	[Route("<#= strRouteBase #>/Recherche/{Text}", HttpVerbs.Get, Summary = "<#= string.Format(searchDescription, entityName) #>", Notes = SwaggerDescriptions.SearchRequestNotes)]
<#
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= searchClassName #> : IReturn<List<BaseEntity>>, IGet
	{
		/// <summary>
		/// <#= FormatXmlDoc(textPropDescription) #>
		/// </summary>
<#
			    if (AddApiAttributes)
                {
#>
		[ApiMember(Description = "<#= textPropDescription #>", DataType = SwaggerDataTypes.String, IsRequired = true, ParameterType = SwaggerParamTypes.Path)]
<#
                }
#>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>string Text { get; set; }

		/// <summary>
		/// <#= FormatXmlDoc(maxPropDescription) #>
		/// </summary>
<#
			    if (AddApiAttributes)
                {
#>
		[ApiMember(Description = "<#= maxPropDescription #>", DataType = SwaggerDataTypes.Int)]
<#
                }
#>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>int Max { get; set; }
	}

<#
            }
        }
#>
}
<#
		manager.EndBlock(); // end newfile (msg)
    } // end foreach (table)

	//manager.StartFooter();
	//manager.EndBlock(); // end footer
	
    manager.Process(SplitIntoMultipleFiles);
#>
<#+
private string FormatXmlDoc(string str, params string[] crefs)
{
	if (string.IsNullOrEmpty(str))
    {
		return string.Empty;
    }
	if (crefs != null)
    {
		str = string.Format(str, crefs.Select(s => "<see cref=\"" + s + "\"/>").ToArray());
    }
	if (!str.EndsWith("."))
    {
		return str.Trim() + "."; 
    }
	return str;
}

private string GetGeneratedFilename(string filename, string fileNamespace, string baseNamespace)
{
	if (fileNamespace == baseNamespace)
    {
		return filename;
    }

	string str = fileNamespace.Replace(baseNamespace, "");
	if (str.StartsWith("."))
    {
		str = str.Remove(0, 1);
    }
	if (!str.EndsWith("."))
    {
		str = str + ".";
    }
	return str + filename;
}

/// <summary>
/// Retourne une chaine qui représente le format que doit avoir une colonne standard (CodObjet, LibObjet, TxtObjet...) dans une table.
/// Exemple : GenService => "{0}Service" ; GenPersonneProfil => "{0}Profil" ...
/// </summary>
private string GetStandardColumnFormat(Table table)
{
	var parentFkey = GetParentFKey(table);
	if (parentFkey != null)
	{
		return parentFkey.FromTable.ClassName.Replace(parentFkey.ReferencedTable.ClassName, "{0}");
	}
	return "{0}" + table.Name;
}

private void SetColumnsDescription(Table table, string stdColFormat)
{
	foreach (var col in table.Columns)
    {
		if (string.IsNullOrWhiteSpace(col.Description))
        {
			if (col.IsPKey)
			{
				col.Description = "Identifiant unique";
			}
			else if (col.PropertyName == string.Format(stdColFormat, "Cod"))
			{
				col.Description = "Code";
			}
			else if (col.PropertyName == string.Format(stdColFormat, "Lib"))
			{
				col.Description = "Désignation";
			}
			else if (col.PropertyName == string.Format(stdColFormat, "Txt"))
			{
				col.Description = "Commentaire ou description";
			}
			else
			{
				switch (col.PropertyName)
				{
					case "EstActif":
						col.Description = "Actif ou inactif";
						break;
					case "DatCreation":
						col.Description = "Date de création (immutable)";
						break;
					case "CleCreateur":
						col.Description = "Identifiant unique de l'utilisateur responsable de la création (immutable)";
						break;
					case "DatEdition":
						col.Description = "Date de dernière modification (immutable)";
						break;
					case "CleEditeur":
						col.Description = "Identifiant unique de l'utilisateur responsable de la dernière modification (immutable)";
						break;
					case "CodExterne":
						col.Description = "Identifiant de synchronisation externe";
						break;

					case "NumTelep":
						col.Description = "Numéro de téléphone";
						break;
					case "NumFax":
						col.Description = "Numéro de fax";
						break;
					case "NumEmail":
						col.Description = "Adresse email";
						break;

					case "AdrRue":
						col.Description = "Rue";
						break;
					case "AdrCode":
						col.Description = "Code postal";
						break;
					case "AdrCommune":
						col.Description = "Ville ou commune";
						break;
					case "AdrPays":
						col.Description = "Pays";
						break;
				}
			}
        }
		/*
		else if (!col.Description.EndsWith("."))
		{
			col.Description += ".";
		}
		*/

		if (col.IsAutoIncrement || col.IsComputed)
        {
			string desc = col.Description + " (immutable)";
			col.Description = desc.Trim();
        }
		bool isUniqueSingleCol = table.Indices
			.Where(idx => idx.IsUnique == true && idx.IndexColumns.Count == 1 && idx.IndexColumns.Contains(col))
			.Any();
		if (isUniqueSingleCol)
        {
			string desc = col.Description + " (unique)";
			col.Description = desc.Trim();
        }
    }
}

private Dictionary<string, string> GetApiMemberProps(Column col, IEnumerable<string> lstEnums, List<string> lstInterfaces)
{
    if (lstInterfaces.Contains("IAuditable") &&
		(col.PropertyName == "DatCreation" || col.PropertyName == "CleCreateur" || col.PropertyName == "DatEdition" || col.PropertyName == "CleEditeur"))
    {
        return null;
    }

    var dicApiMemberProps = new Dictionary<string, string>();

    if (!string.IsNullOrEmpty(col.Description))
    {
		string str = col.Description;
		if (str.EndsWith(".") && !str.EndsWith("..."))
        {
			str = str.Remove(str.Length - 1, 1);
        }
        dicApiMemberProps.Add("Description", "\"" + str + "\"");
    }
                
    string swagDataType = "";

    if (lstEnums.Contains(col.PropertyType))
    {
        //swagDataType = "SwaggerDataTypes.String";
    }
    else if (col.PropertyType == "byte[]")
    {
        swagDataType = "SwaggerDataTypes.File";
    }
    else
    {
        swagDataType = "SwaggerDataTypes." + col.PropertyType.Substring(0,1).ToUpper() + col.PropertyType.Substring(1);
    }

    if (!string.IsNullOrEmpty(swagDataType))
    {
        dicApiMemberProps.Add("DataType", swagDataType);
    }

    if (col.IsNullable == false)
    {
        dicApiMemberProps.Add("IsRequired", "true");
    }

	return dicApiMemberProps;
}

/// <summary>
/// Retourne les colonnes qui identifient l'entité.
/// </summary>
private List<Column> GetKeyColumns(Table table)
{
	if (table.PrimaryKey != null)
    {
		return table.PrimaryKey.PKeyColumns;
    }
	return null;
}

/// <summary>
/// Retourne la FK pointant sur la table parent la plus proche avec un nom similaire.
/// </summary>
private FKey GetParentFKey(Table table)
{
    var fkey = table.ForeignKeys
		.Where(fk => table.Name.StartsWith(fk.ReferencedTable.Name))
		.Where(fk => table.Name != fk.ReferencedTable.Name)
		.OrderByDescending(fk => fk.ReferencedTable.Name.Length) // si plusieurs parents, on prend celui avec le nom le plus long
		.FirstOrDefault();
	return fkey;
}

/// <summary>
/// Extraction des colonnes route path suivant les ForeignKeys/enfants
/// </summary>
private List<Column> GetRouteColumns(Table table, bool recurseParents)
{
	var lstCols = new List<Column>();

	if (recurseParents)
    {
		var fkParent = GetParentFKey(table);
		if (fkParent != null)
		{
			var parentTable = fkParent.ReferencedTable;

			var lst = GetRouteColumns(parentTable, recurseParents);
			lstCols.AddRange(lst);
		}
    }

	var parentCols = GetKeyColumns(table);
    if (parentCols != null)
	{
		lstCols.AddRange(parentCols);
    }

	return lstCols;
}

private string ReplaceFirst(string text, string search, string replace)
{
	int pos = text.IndexOf(search);
	if (pos < 0)
	{
		return text;
	}
	return text.Substring(0, pos) + replace + text.Substring(pos + search.Length);
}

private string GetStrRoutePath(List<Column> lstCols, bool keepEnd = true, bool removeUselessCols = true)
{
	string strRoute = "";
	string currentTable = "";

	var lastCol = lstCols.Last();
	var tbl = lastCol.ParentTable;

	foreach (var phCol in lstCols)
    {
		if (phCol.ParentTable.ClassName != currentTable)
        {
			string newTableName = phCol.ParentTable.ClassName;
			if (currentTable != "")
            {
				newTableName = ReplaceFirst(phCol.ParentTable.ClassName, currentTable, ""); 
            }
			strRoute += "/" + newTableName;

			currentTable = phCol.ParentTable.ClassName;
        }

		string strCol = "{" + phCol.PropertyName + "}";
		if (!strRoute.Contains(strCol))
        {
			if (removeUselessCols && lastCol.IsPKey && phCol != lastCol)
            {
				continue;
            }
			if (keepEnd || (phCol.ParentTable != tbl))
			{
				strRoute += "/";
				strRoute += strCol;
			}
        }
    }

	return strRoute;
}

private string GetEntityName(List<Column> lstCols)
{
	var parts = new List<string>();

	string currentTable = "";
	foreach (var phCol in lstCols)
    {
		if (phCol.ParentTable.ClassName != currentTable)
        {
			string newTableName = phCol.ParentTable.ClassName;
			if (currentTable != "")
            {
				newTableName = ReplaceFirst(phCol.ParentTable.ClassName, currentTable, "");
            }
			
			parts.Add(newTableName);

			currentTable = phCol.ParentTable.ClassName;
        }
    }
	
	if (parts.Count == 0)
    {
		return "";
    }
	else
    {
		string res = parts.Last();

		if (parts.Count == 1)
        {
			return res;
        }
		else
		{
			string parentRes = string.Join("/", parts.Where(p => p != res));
			return string.Format("{0} ({1})", res, parentRes);
        }
    }
}
#>
