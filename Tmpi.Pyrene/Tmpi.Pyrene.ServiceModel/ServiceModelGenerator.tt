<#@ template language="C#" hostspecific="true" debug="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Configuration" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Configuration" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Linq" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\MultipleOutputHelper.ttinclude" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\VisualStudioHelper.ttinclude" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\SqlSchemaReader.ttinclude" #>
<#
	/***** TODO *****
	- DefaultAttribute
    - Commentaires sur les [References] ?
    - Ajout de propriétés [References] pour les FK ?
	- Possibilité d'avoir 0 PK ?
	****************/

	/*********************/
	/** CUSTOM SETTINGS **/
	/*********************/

	// chaine de connection pour l'extration du schéma
    string ConnectionStringName = "PyreneModel";
	string ConnectionString = "";

	// schema a extraire ou vide pour tous les schémas
	string SchemaName = "";

    // Namespace des fichiers générés.
	// {0} = DefaultNamespace du projet/répertoire courant.
    string NamespacePocos = "{0}.Types";
    string NamespaceMessages = "{0}.Messages";

    // true pour générer des classes partial.
    bool MakeClassesPartial = true;

    // true pour générer des propriétés virtual.
    bool MakePocoPropertiesVirtual = false;
    bool MakeMessagePropertiesVirtual = false;

    // true pour générer chaque classe dans un fichier séparé.
    bool SplitIntoMultipleFiles = true;

    // if true: Changes the primary key property name to Id.
    bool UseIdAsPK = false;

    // if true: Adds explicit '[Schema]' attribute.
    bool UseSchemaAttribute = true;

    // if true: Adds References(typeof(ReferenceTableType)) to FKs.
    bool IncludeReferences = true;

    // true: Ajoute [Index] et [CompositeIndex].
    bool IncludeIndices = true;

    // Ajoute les interfaces IAuditable, etc...
    bool AddCustomInterfaces = true;

    // Ajoute des propriétés avec l'attribut [Reference] pour les tables enfants
    bool AddChildReferences = true;

    // Ajoute [ApiMember], [ApiAllowableValues]...
    bool AddApiAttributes = true;

    // true pour ajouter l'attribut [Route(...)] sur les classes générées.
    bool AddRouteAttributes = true;

    // true pour transformer la route de l'entité, ex: GenFournContact de '/GenFournContact/' en '/GenFourn/{xxx}/Contact/'.
    bool TransformRoutePath = true;

    // Filtre globalement les messages générés.
	Regex MsgTableFilterExclude = null;

    // Filtre les messages générés par type de message.
    Regex PostTableFilterExclude = null;
	Regex GetTableFilterExclude = null;
	Regex DeleteTableFilterExclude = null;
	Regex PatchTableFilterExclude = null;
	Regex SearchTableFilterExclude = null;
	Regex SelectTableFilterExclude = null;

    // Si non null, méthode appliquée sur la collection des tables
    Action<Tables> TweakSchema = (tables) =>
    {	
		foreach (Table table in tables)
        {
			string stdColFormat = GetStandardColumnFormat(table);
			SetColumnsDescription(table, stdColFormat);
        }

		tables.RemoveAll(t => t.Name == "__RefactorLog");

		tables.ChangePropertyType("GenCompteur", "TypCompteur", "TypCompteur");
		tables.ChangePropertyType("GenCompteur", "TypPeriodicite", "TypPeriodicite");
		tables.ChangePropertyType("GenMandat", "TypMandat", "TypMandat");
		tables.ChangePropertyType("GenPersonne", "TypCivilite", "TypCivilite");
		tables.ChangePropertyType("GenFourn", "TypModeReglement", "TypModeReglement");
		tables.ChangePropertyType("GenFournContact", "TypCivilite", "TypCivilite");
    };

#>
<#
    Manager manager = Manager.Create(Host, GenerationEnvironment);
    manager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable 1591

using System;
using System.Collections.Generic;
using System.Net;
using System.Runtime.Serialization;
using ServiceStack;
using ServiceStack.DataAnnotations;
using ServiceStack.Model;
<#
	manager.EndBlock(); // end header
    
    // Get a reference to the project of this t4 template
    Project project = VisualStudioHelper.CurrentProject;
	
	string t4fileNamespace = VisualStudioHelper.CurrentFileNamespace;

	// Contient tous les enums du projet
    List<string> allEnums = VisualStudioHelper.CodeModel.GetAllCodeElementsOfType(project.CodeModel.CodeElements, vsCMElement.vsCMElementEnum, false)
        .OfType<CodeEnum>()
		.Select(x => x.Name)
		.ToList();

	if (string.IsNullOrWhiteSpace(ConnectionString))
    {
		string providerName;
		ConnectionString = GetConnectionString(project, ConnectionStringName, out providerName);
    }
	
    // Read schema
    Tables allTables = LoadTables(ConnectionString, SchemaName, false);
    if (TweakSchema != null)
    {
        TweakSchema(allTables);
    }

    foreach (Table table in allTables)
    {
	    bool msgExcluded = MsgTableFilterExclude != null && MsgTableFilterExclude.IsMatch(table.ClassName);

		/****************/
		/** BEGIN POCO **/
		/****************/

		string pocoNamespace = string.Format(NamespacePocos, t4fileNamespace);
		string pocoFileName = GetGeneratedFilename(table.ClassName, pocoNamespace, t4fileNamespace);
        manager.StartNewFile(pocoFileName + ".generated.cs");

#>

namespace <#= pocoNamespace #>
{
<#
        List<string> lstInterfaces = new List<string>();

		if (table.PrimaryKey == null)
        {
			string errorMsg = string.Format("[{0}].[{1}] : La table est ignorée car elle n'a pas de clé primaire.",
				table.Schema, table.Name);
			Error(errorMsg);
#>
	// <#= errorMsg #>
<#
			continue;
        }
        else
        {
			if (table.PrimaryKey.PKeyColumns.Count > 1)
            {
				string errorMsg = string.Format("[{0}].[{1}].[{2}] : OrmLite ne supporte pas les clés primaires composites ; la table est ignorée.",
					table.Schema, table.Name, table.PrimaryKey.Name);
				Error(errorMsg);
#>
	// <#= errorMsg #>
<#
				continue;
            }

			Column pkCol = table.PrimaryKey.PKeyColumns.Single();
            if (UseIdAsPK)
            {
                pkCol.PropertyName = "Id";
            }
            if (pkCol.PropertyName == "Id")
            {
                lstInterfaces.Add("IHasId<" + pkCol.PropertyType + ">");
            }
        }
        if (AddCustomInterfaces)
        {
            if (table.Columns.Any(c => c.PropertyName == "DatCreation" && c.ProperPropertyType == "DateTime") &&
                table.Columns.Any(c => c.PropertyName == "DatEdition" && c.ProperPropertyType == "DateTime?") &&
				table.Columns.Any(c => c.PropertyName == "CleCreateur" && c.ProperPropertyType == "int") &&
				table.Columns.Any(c => c.PropertyName == "CleEditeur" && c.ProperPropertyType == "int?"))
            {
                lstInterfaces.Add("IAuditable");
            }
        }

        if (table.ClassName != table.Name)
        {
#>
	[Alias("<#= table.Name #>")]
<#
        }
		
        if (UseSchemaAttribute && !string.IsNullOrEmpty(table.Schema) && table.Schema != "dbo")
        {
#>
	[Schema("<#= table.Schema #>")]
<#
        }
		
        if (IncludeIndices)
        {
			IEnumerable<TableIndex> compositeIdx = table.Indices.Where(i => i.IndexColumns.Count > 1);
            foreach (TableIndex idx in compositeIdx)
            {
				IEnumerable<string> q = idx.IndexColumns
					.Select(c => (c.Name == c.PropertyName) ? string.Format("nameof({0})", c.PropertyName) : string.Format("\"{0}\"", c.Name));
#>
	[CompositeIndex(<#= idx.IsUnique ? "true, " : "" #><#= string.Join(", ", q) #>)]
<#
            }
        }

		List<Column> lstPlaceholderCols = GetRouteColumns(table, TransformRoutePath);

		string resourceName = GetResourceName(lstPlaceholderCols);

        if (!msgExcluded && AddRouteAttributes)
        {
			bool postExcluded = PostTableFilterExclude != null && PostTableFilterExclude.IsMatch(table.ClassName);
            if (!postExcluded)
            {
				string strRoute = GetStrRoutePath(lstPlaceholderCols, false, false);
#>
    [Route("<#= strRoute #>", HttpVerbs.Post, Summary = "<#= string.Format("Ajoute ou remplace une entité {0} à partir de son id", resourceName) #>")]
<#
            }

            if (AddApiAttributes)
            {
#>
    [ApiResponse(HttpStatusCode.NotFound, "L'entité spécifiée est introuvable")]
    [ApiResponse(HttpStatusCode.Conflict, "L'entité spécifiée est un doublon")]
<#
            }
        }

		List<string> pocoInterfaces = new List<string>();
		if (!msgExcluded)
        {
			pocoInterfaces.Add("IReturn<" + table.ClassName + ">");
			pocoInterfaces.Add("IPost");
        }
		pocoInterfaces.AddRange(lstInterfaces);
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= table.ClassName #><#= pocoInterfaces.Any() ? " : " + string.Join(", ", pocoInterfaces) : "" #>
	{
<#
        foreach (Column col in table.Columns)
        {
            if (!string.IsNullOrWhiteSpace(col.Description))
            {
#>
		/// <summary>
		/// <#= FormatXmlDocSummary(col.Description) #>
		/// </summary>
<#
			}
			if (col.Name != col.PropertyName)
			{
#>
        [Alias("<#= col.Name #>")]
<#
			}

			if (col.PropertyType == "string" && col.Size > 0)
			{   
#>
		[StringLength(<#= col.Size #>)]
<#
            }
            else if (col.PropertyType == "decimal" && col.Precision > 0)
            {
#>
		[DecimalLength(<#= col.Precision #>, <#= col.Scale #>)]
<#
            }

            if (col.IsAutoIncrement)
            {
#>
		[AutoIncrement]
<#
            }

            if (col.IsComputed)
            {
#>
		[Compute]        
<#
            }

            if (IncludeReferences)
            {
                FKey thisFKey = table.ForeignKeys.Where(fk => fk.FromColumns.Contains(col)).FirstOrDefault();
                if (thisFKey != null)
                {
                    if (string.IsNullOrEmpty(thisFKey.DeleteRule))
                    {
#>
		[References(typeof(<#= thisFKey.ReferencedTable.ClassName #>))]
<#
                    }
                    else
                    {
#>
		[ForeignKey(typeof(<#= thisFKey.ReferencedTable.ClassName #>), OnDelete = "<#= thisFKey.DeleteRule #>")]
<#
                    }
                }
            }

            if (col.IsNullable == false && col.IsAutoIncrement == false)
            {
#>
		[Required]
<#
            }

            if (IncludeIndices)
            {
				TableIndex index = table.Indices.Where(idx => idx.IndexColumns.Count == 1 && idx.IndexColumns.Contains(col)).FirstOrDefault();
                if (index != null)
                {
#>
		[Index<#= index.IsUnique ? "(true)" : "" #>]
<#
                }
            }

            if (col.IsPKey && (col.PropertyName != "Id"))
            {
#>
		[PrimaryKey]
<#
            }

			if (AddApiAttributes)
            {
				Dictionary<string, string> dicApiMemberProps = GetApiMemberProps(col, allEnums, lstInterfaces);
				if (dicApiMemberProps != null)
                {
					if (lstPlaceholderCols.Any(c => c.PropertyName == col.PropertyName))
					{
						if (!col.IsPKey || col.IsFKey)
                        {
							dicApiMemberProps.Add("ParameterType", "SwaggerParamTypes.Path");
                        }
					}
#>
		[ApiMember(<#= string.Join(", ", dicApiMemberProps.Select(kvp => kvp.Key + " = " + kvp.Value)) #>)]
<#
                }

                if (allEnums.Contains(col.PropertyType))
                {
#>
		[ApiAllowableValues(nameof(<#= col.PropertyName #>), typeof(<#= col.PropertyType #>))]
<#
                }

            }
#>
		public <#= MakePocoPropertiesVirtual ? "virtual " : "" #><#= col.ProperPropertyType #> <#= col.PropertyName #> { get; set; }

<#
        } // end foreach (col)

        if (AddChildReferences)
        {
           var q = from tbl in allTables
					where tbl.Name.StartsWith(table.Name)
					from fk in tbl.ForeignKeys
					where fk.ReferencedTable == table
					let fkCol = fk.FromColumns.Single()
					let fkIsPK = tbl.PrimaryKey != null && tbl.PrimaryKey.PKeyColumns.Contains(fkCol)
					let fkIsUnique = tbl.Indices.Any(idx => idx.IsUnique && idx.IndexColumns.Count == 1 && idx.IndexColumns.Contains(fkCol))
					select new
					{
						Table = tbl,
						IsUnique = fkIsPK || fkIsUnique
					};
            foreach (var obj in q)
            {
                string propType = obj.Table.ClassName;
                string propName = "";
				if (obj.Table.ClassName == table.ClassName)
                {
					propName = table.ClassName.Remove(0, 3);
                }
				else
                {
					propName = obj.Table.ClassName.Replace(table.ClassName, "");
                }
                if (!obj.IsUnique)
                {
                    propType = "List<" + propType + ">";
                    propName = "Lst" + propName;
                }
#>
		[Reference]
		public <#= MakePocoPropertiesVirtual ? "virtual " : "" #><#= propType #> <#= propName #> { get; set; }

<#
            }
        }
#>
	}
}
<#
		manager.EndBlock(); // end newfile (poco)

		if (msgExcluded)
        {
			continue;
        }

		string msgNamespace = string.Format(NamespaceMessages, t4fileNamespace);
		string msgFileName = GetGeneratedFilename(table.ClassName, msgNamespace, t4fileNamespace);
		manager.StartNewFile(msgFileName + ".generated.cs");

		if (pocoNamespace != msgNamespace)
        {
#>
using <#= pocoNamespace #>;
<#
		}
#>

namespace <#= msgNamespace #>
{
<#
		/******************/
		/** BEGIN SELECT **/
		/******************/

		bool selectExcluded = SelectTableFilterExclude != null && SelectTableFilterExclude.IsMatch(table.ClassName);
		if (!selectExcluded)
		{
			string selectTableClassName = "Select" + table.ClassName;
			string selectTableClassDescription = string.Format("Retourne une collection des entités {0}", resourceName);
			string skipPropDescription = "Nombre d'éléments à ignorer avant de retourner les éléments restants";
			string takePropDescription = "Nombre d'éléments à retourner";
			string sortPropDescription = "Tri";

#>
	/// <summary>
	/// <#= FormatXmlDocSummary(selectTableClassDescription) #>
	/// </summary>
	/// <seealso cref="<#= table.ClassName #>"/>
<#
            if (AddRouteAttributes)
            {
				string strRoute = GetStrRoutePath(lstPlaceholderCols, false, false);
#>
	[Route("<#= strRoute #>", HttpVerbs.Get, Summary = "<#= selectTableClassDescription #>")]
<#
			    if (AddApiAttributes)
                {
#>
    [ApiResponse(HttpStatusCode.NotFound, "L'entité spécifiée est introuvable")]
<#
                }
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= selectTableClassName #> : IReturn<<#= selectTableClassName #>Response>, IGet, IPagination
	{
<#
			Column lastCol = lstPlaceholderCols.LastOrDefault();
            foreach (Column phCol in lstPlaceholderCols)
            {
				if (lastCol != null && lastCol.IsPKey && lastCol == phCol)
				{
					continue; // on ne prend que les colonnes foreign key
				}
				Column newCol = phCol.Clone();
				Column refCol = table.Columns.First(c => c.PropertyName == phCol.PropertyName);
				if (refCol != null)
                {
					newCol.Description = refCol.Description;
                }

				if (!string.IsNullOrWhiteSpace(newCol.Description))
				{
#>
        /// <summary>
        /// <#= FormatXmlDocSummary(newCol.Description) #>
        /// </summary>
<#
				}
				if (AddApiAttributes)
				{
					Dictionary<string, string> dicApiMemberProps = GetApiMemberProps(newCol, allEnums, lstInterfaces);
					if (dicApiMemberProps != null)
					{
						dicApiMemberProps.Add("ParameterType", "SwaggerParamTypes.Path");
#>
		[ApiMember(<#= string.Join(", ", dicApiMemberProps.Select(kvp => kvp.Key + " = " + kvp.Value)) #>)]
<#
					}
				}
#>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #><#= newCol.ProperPropertyType #> <#= newCol.PropertyName #> { get; set; }

<#
            }

#>
        /// <summary>
        /// <#= FormatXmlDocSummary(skipPropDescription) #>
        /// </summary>
<#
			if (AddApiAttributes)
            {
#>
		[ApiMember(Description = "<#= skipPropDescription #>", DataType = SwaggerDataTypes.Int)]
<#
            }
#>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>int? Skip { get; set; }

        /// <summary>
        /// <#= FormatXmlDocSummary(takePropDescription) #>
        /// </summary>
<#
			if (AddApiAttributes)
            {
#>
		[ApiMember(Description = "<#= takePropDescription #>", DataType = SwaggerDataTypes.Int)]
<#
            }
#>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>int? Take { get; set; }

        /// <summary>
        /// <#= FormatXmlDocSummary(sortPropDescription) #>
        /// </summary>
<#
			if (AddApiAttributes)
            {
#>
		[ApiMember(Description = "<#= sortPropDescription #>", DataType = SwaggerDataTypes.ArrayOfString)]
<#
            }
#>
		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>string[] Sort { get; set; }
	}

    /// <summary>
    /// <#= FormatXmlDocSummary("Réponse à la requête <see cref=\"" + selectTableClassName + "\"/>.") #>
    /// </summary>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= selectTableClassName #>Response
	{
		public ResponseStatus ResponseStatus { get; set; }

		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>int TotalCount { get; set; }

		public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>List<<#= table.ClassName #>> Results { get; set; }
	}

<#
        }

		/********************/
		/** BEGIN GET BYID **/
		/********************/

		bool getExcluded = GetTableFilterExclude != null && GetTableFilterExclude.IsMatch(table.ClassName);
		if (!getExcluded)
		{
			string getTableClassName = "Get" + table.ClassName;
			string getTableClassDescription = string.Format("Retourne une entité {0} à partir de son id", resourceName);
			string fieldsPropDescription = "Champs à retourner, ou null pour retourner tous les champs";
#>
	/// <summary>
	/// <#= FormatXmlDocSummary(getTableClassDescription) #>
	/// </summary>
	/// <seealso cref="<#= table.ClassName #>"/>
<#
            if (AddRouteAttributes)
            {
				string strRoute = GetStrRoutePath(lstPlaceholderCols);
#>
	[Route("<#= strRoute #>", HttpVerbs.Get, Summary = "<#= getTableClassDescription #>")]
<#
			    if (AddApiAttributes)
                {
#>
    [ApiResponse(HttpStatusCode.BadRequest, "L'entité ne contient pas tous les champs demandés")]
    [ApiResponse(HttpStatusCode.NotFound, "L'entité spécifiée est introuvable")]
<#
                }
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= getTableClassName #> : IReturn<<#= table.ClassName #>>, IGet
	{
<#
		Column lastCol = lstPlaceholderCols.LastOrDefault();
		foreach (Column phCol in lstPlaceholderCols)
		{
			if (lastCol != null && lastCol.IsPKey && lastCol != phCol)
            {
				continue; // on ignore les colonnes qui ne sont pas la PK de l'entité
            }
			Column newCol = phCol.Clone();
			newCol.Description = "Identifiant unique de l'entité à retourner";

			if (!string.IsNullOrWhiteSpace(newCol.Description))
            {
#>
        /// <summary>
        /// <#= FormatXmlDocSummary(newCol.Description) #>
        /// </summary>
<#
            }
			if (AddApiAttributes)
            {
				Dictionary<string, string> dicApiMemberProps = GetApiMemberProps(newCol, allEnums, lstInterfaces);
				if (dicApiMemberProps != null)
                {
					dicApiMemberProps.Add("ParameterType", "SwaggerParamTypes.Path");
#>
		[ApiMember(<#= string.Join(", ", dicApiMemberProps.Select(kvp => kvp.Key + " = " + kvp.Value)) #>)]
<#
                }
            }
#>
        public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #><#= newCol.ProperPropertyType #> <#= newCol.PropertyName #> { get; set; }

<#
		}
#>
        /// <summary>
        /// <#= FormatXmlDocSummary(fieldsPropDescription) #>
        /// </summary>
<#
			    if (AddApiAttributes)
                {
#>
        [ApiMember(Description = "<#= fieldsPropDescription #>", DataType = SwaggerDataTypes.ArrayOfString)]
<#
                }
#>
        public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>string[] Fields { get; set; }
	}

<#
		}

		/***********************/
		/** BEGIN DELETE BYID **/
		/***********************/

		bool deleteExcluded = DeleteTableFilterExclude != null && DeleteTableFilterExclude.IsMatch(table.ClassName);
		if (!deleteExcluded)
		{
			string deleteTableClassName = "Delete" + table.ClassName;
			string deleteTableClassDescription = string.Format("Supprime une entité {0} à partir de son id", resourceName);
#>
	/// <summary>
	/// <#= FormatXmlDocSummary(deleteTableClassDescription) #>
	/// </summary>
	/// <seealso cref="<#= table.ClassName #>"/>
<#
            if (AddRouteAttributes)
            {
				string strRoute = GetStrRoutePath(lstPlaceholderCols);
#>
	[Route("<#= strRoute #>", HttpVerbs.Delete, Summary = "<#= deleteTableClassDescription #>")]
<#
			    if (AddApiAttributes)
                {
#>
    [ApiResponse(HttpStatusCode.NotFound, "L'entité spécifiée est introuvable")]
<#
                }
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= deleteTableClassName #> : IReturnVoid, IDelete
	{
<#
		Column lastCol = lstPlaceholderCols.LastOrDefault();
		foreach (Column phCol in lstPlaceholderCols)
		{
			if (lastCol != null && lastCol.IsPKey && lastCol != phCol)
            {
				continue; // on ignore les colonnes qui ne sont pas la PK de l'entité
            }
			Column newCol = phCol.Clone();
			newCol.IsNullable = false;
			newCol.Description = "Identifiant unique de l'entité à supprimer";

			if (!string.IsNullOrWhiteSpace(newCol.Description))
            {
#>
        /// <summary>
        /// <#= FormatXmlDocSummary(newCol.Description) #>
        /// </summary>
<#
            }
			if (AddApiAttributes)
            {
				Dictionary<string, string> dicApiMemberProps = GetApiMemberProps(newCol, allEnums, lstInterfaces);
				if (dicApiMemberProps != null)
                {
					dicApiMemberProps.Add("ParameterType", "SwaggerParamTypes.Path");
#>
		[ApiMember(<#= string.Join(", ", dicApiMemberProps.Select(kvp => kvp.Key + " = " + kvp.Value)) #>)]
<#
                }
            }
#>
        public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #><#= newCol.ProperPropertyType #> <#= newCol.PropertyName #> { get; set; }

<#
		}
#>
	}

<#
		}

		/**********************/
		/** BEGIN PATCH BYID **/
		/**********************/

		bool patchExcluded = PatchTableFilterExclude != null && PatchTableFilterExclude.IsMatch(table.ClassName);
		if (!patchExcluded)
		{
			string patchTableClassName = "Patch" + table.ClassName;
			string patchTableClassDescription = string.Format("Modifie partiellement une entité {0} à partir de son id", resourceName);
			string fieldsPropDescription = "Liste des modifications à appliquer";
#>
	/// <summary>
	/// <#= FormatXmlDocSummary(patchTableClassDescription) #>
	/// </summary>
	/// <seealso cref="<#= table.ClassName #>"/>
<#
            if (AddRouteAttributes)
            {
				string strRoute = GetStrRoutePath(lstPlaceholderCols);
#>
	[Route("<#= strRoute #>", HttpVerbs.Patch, Summary = "<#= patchTableClassDescription #>")]
<#
			    if (AddApiAttributes)
                {
#>
    [ApiResponse(HttpStatusCode.BadRequest, "L'entité ne contient pas tous les champs demandés")]
    [ApiResponse(HttpStatusCode.NotFound, "L'entité spécifiée est introuvable")]
    [ApiResponse(HttpStatusCode.Conflict, "L'entité spécifiée est un doublon")]
<#
                }
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= patchTableClassName #> : IReturnVoid, IPatch
	{
<#
		Column lastCol = lstPlaceholderCols.LastOrDefault();
		foreach (Column phCol in lstPlaceholderCols)
		{
			if (lastCol != null && lastCol.IsPKey && lastCol != phCol)
            {
				continue; // on ignore les colonnes qui ne sont pas la PK de l'entité
            }
			Column newCol = phCol.Clone();
			newCol.Description = "Identifiant unique de l'entité à modifier";

			if (!string.IsNullOrWhiteSpace(newCol.Description))
            {
#>
        /// <summary>
        /// <#= FormatXmlDocSummary(newCol.Description) #>
        /// </summary>
<#
            }
			if (AddApiAttributes)
            {
				Dictionary<string, string> dicApiMemberProps = GetApiMemberProps(newCol, allEnums, lstInterfaces);
				if (dicApiMemberProps != null)
                {
					dicApiMemberProps.Add("ParameterType", "SwaggerParamTypes.Path");
#>
		[ApiMember(<#= string.Join(", ", dicApiMemberProps.Select(kvp => kvp.Key + " = " + kvp.Value)) #>)]
<#
                }
            }
#>
        public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #><#= newCol.ProperPropertyType #> <#= newCol.PropertyName #> { get; set; }

<#
		}
#>
        /// <summary>
        /// <#= FormatXmlDocSummary(fieldsPropDescription) #>
        /// </summary>
<#
			    if (AddApiAttributes)
                {
#>
        [ApiMember(Description = "<#= fieldsPropDescription #>", DataType = "Array[" + nameof(Patch) + "]", IsRequired = true, ParameterType = SwaggerParamTypes.Form)]
<#
                }
#>
        public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>Patch[] Fields { get; set; }
	}

<#
		}

		string stdColFormat = GetStandardColumnFormat(table);
		bool hasPK = (table.PrimaryKey != null);
		bool hasCodObjet = table.Columns.Any(c => c.PropertyType == "string" && c.PropertyName == string.Format(stdColFormat, "Cod"));
		bool hasLibObjet = table.Columns.Any(c => c.PropertyType == "string" && c.PropertyName == string.Format(stdColFormat, "Lib"));
		bool hasEstActif = table.Columns.Any(c => c.PropertyType == "bool" && c.PropertyName == "EstActif");

		if (hasPK && hasCodObjet && hasLibObjet && hasEstActif)
        {
			/************************/
			/** BEGIN AUTOCOMPLETE **/
			/************************/

			bool searchExcluded = SearchTableFilterExclude != null && SearchTableFilterExclude.IsMatch(table.ClassName);
			if (!searchExcluded)
			{
				var searchClassName = "Search" + table.ClassName;
				var searchDescription = string.Format("Retourne le résultat d'une recherche sur les entités {0}", resourceName);
				var textPropDescription = "Texte à rechercher";
				var maxPropDescription = "Nombre maximum de résultats à retourner";
#>
	/// <summary>
	/// <#= FormatXmlDocSummary(searchDescription) #>
	/// </summary>
	/// <seealso cref="<#= table.ClassName #>"/>
<#
			if (AddRouteAttributes)
            {
				string strRouteBase = GetStrRoutePath(lstPlaceholderCols, false);
#>
	[Route("<#= strRouteBase #>/Recherche/{Text}", HttpVerbs.Get, Summary = "<#= searchDescription #>")]
<#
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= searchClassName #> : IReturn<List<BaseEntity>>, IGet
	{
        /// <summary>
        /// <#= FormatXmlDocSummary(textPropDescription) #>
        /// </summary>
<#
			    if (AddApiAttributes)
                {
#>
        [ApiMember(Description = "<#= textPropDescription #>", DataType = SwaggerDataTypes.String, IsRequired = true, ParameterType = SwaggerParamTypes.Path)]
<#
                }
#>
        public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>string Text { get; set; }

        /// <summary>
        /// <#= FormatXmlDocSummary(maxPropDescription) #>
        /// </summary>
<#
			    if (AddApiAttributes)
                {
#>
        [ApiMember(Description = "<#= maxPropDescription #>", DataType = SwaggerDataTypes.Int)]
<#
                }
#>
        public <#= MakeMessagePropertiesVirtual ? "virtual " : "" #>int Max { get; set; }
	}

<#
            }
        }
#>
}
<#
		manager.EndBlock(); // end newfile (msg)
    } // end foreach (table)

	//manager.StartFooter();
	//manager.EndBlock(); // end footer
	
    manager.Process(SplitIntoMultipleFiles);
#>
<#+
private string FormatXmlDocSummary(string str)
{
	if (string.IsNullOrEmpty(str))
    {
		return string.Empty;
    }
	if (!str.EndsWith("."))
    {
		return str.Trim() + "."; 
    }
	return str;
}

private string GetGeneratedFilename(string filename, string fileNamespace, string t4Namespace)
{
	if (fileNamespace == t4Namespace)
    {
		return filename;
    }

	string str = fileNamespace.Replace(t4Namespace, "");
	if (str.StartsWith("."))
    {
		str = str.Remove(0, 1);
    }
	if (!str.EndsWith("."))
    {
		str = str + ".";
    }
	return str + filename;
}

/// <summary>
/// Retourne une chaine qui représente le format que doit avoir une colonne standard (CodObjet, LibObjet, TxtObjet...) dans une table.
/// Exemple : GenService => "{0}Service" ; GenPersonneProfil => "{0}Profil" ...
/// </summary>
private string GetStandardColumnFormat(Table table)
{
	FKey parentFkey = GetParentFKey(table);
	if (parentFkey != null)
	{
		return parentFkey.FromTable.ClassName.Replace(parentFkey.ReferencedTable.ClassName, "{0}");
	}
	return "{0}" + table.Name.Remove(0, 3);
}

private void SetColumnsDescription(Table table, string stdColFormat)
{
	foreach (Column col in table.Columns)
    {
		if (string.IsNullOrWhiteSpace(col.Description))
        {
			if (col.IsPKey)
			{
				col.Description = "Identifiant unique";
			}
			else if (col.PropertyName == string.Format(stdColFormat, "Cod"))
			{
				col.Description = "Code";
			}
			else if (col.PropertyName == string.Format(stdColFormat, "Lib"))
			{
				col.Description = "Désignation";
			}
			else if (col.PropertyName == string.Format(stdColFormat, "Txt"))
			{
				col.Description = "Commentaire ou description";
			}
			else
			{
				switch (col.PropertyName)
				{
					case "EstActif":
						col.Description = "Actif ou inactif";
						break;
					case "DatCreation":
						col.Description = "Date de création (immutable)";
						break;
					case "CleCreateur":
						col.Description = "Identifiant unique de l'utilisateur responsable de la création (immutable)";
						break;
					case "DatEdition":
						col.Description = "Date de dernière modification (immutable)";
						break;
					case "CleEditeur":
						col.Description = "Identifiant unique de l'utilisateur responsable de la dernière modification (immutable)";
						break;
					case "CodExterne":
						col.Description = "Identifiant de synchronisation externe";
						break;

					case "NumTelep":
						col.Description = "Numéro de téléphone";
						break;
					case "NumFax":
						col.Description = "Numéro de fax";
						break;
					case "NumEmail":
						col.Description = "Adresse email";
						break;

					case "AdrRue":
						col.Description = "Rue";
						break;
					case "AdrCode":
						col.Description = "Code postal";
						break;
					case "AdrCommune":
						col.Description = "Ville ou commune";
						break;
					case "AdrPays":
						col.Description = "Pays";
						break;
				}
			}
        }
		/*
		else if (!col.Description.EndsWith("."))
		{
			col.Description += ".";
		}
		*/

		if (col.IsAutoIncrement || col.IsComputed)
        {
			string desc = col.Description + " (immutable)";
			col.Description = desc.Trim();
        }
		bool isUniqueSingleCol = table.Indices
			.Where(idx => idx.IsUnique == true && idx.IndexColumns.Count == 1 && idx.IndexColumns.Contains(col))
			.Any();
		if (isUniqueSingleCol)
        {
			string desc = col.Description + " (unique)";
			col.Description = desc.Trim();
        }
    }
}

private Dictionary<string, string> GetApiMemberProps(Column col, List<string> lstEnums, List<string> lstInterfaces)
{
    if (lstInterfaces.Contains("IAuditable") &&
		(col.PropertyName == "DatCreation" || col.PropertyName == "CleCreateur" || col.PropertyName == "DatEdition" || col.PropertyName == "CleEditeur"))
    {
        return null;
    }

    Dictionary<string, string> dicApiMemberProps = new Dictionary<string, string>();

    if (!string.IsNullOrEmpty(col.Description))
    {
		string str = col.Description;
		if (str.EndsWith(".") && !str.EndsWith("..."))
        {
			str = str.Remove(str.Length - 1, 1);
        }
        dicApiMemberProps.Add("Description", "\"" + str + "\"");
    }
                
    string swagDataType = "";

    if (lstEnums.Contains(col.PropertyType))
    {
        //swagDataType = "SwaggerDataTypes.String";
    }
    else if (col.PropertyType == "byte[]")
    {
        swagDataType = "SwaggerDataTypes.File";
    }
    else
    {
        swagDataType = "SwaggerDataTypes." + col.PropertyType.Substring(0,1).ToUpper() + col.PropertyType.Substring(1);
    }

    if (!string.IsNullOrEmpty(swagDataType))
    {
        dicApiMemberProps.Add("DataType", swagDataType);
    }

    if (col.IsNullable == false)
    {
        dicApiMemberProps.Add("IsRequired", "true");
    }

	return dicApiMemberProps;
}

/// <summary>
/// Retourne les colonnes qui identifient l'entité.
/// </summary>
private List<Column> GetKeyColumns(Table table)
{
	if (table.PrimaryKey != null)
    {
		return table.PrimaryKey.PKeyColumns;
    }
	return null;
}

/// <summary>
/// Retourne la FK pointant sur la table parent la plus proche avec un nom similaire.
/// </summary>
private FKey GetParentFKey(Table table)
{
    FKey fkey = table.ForeignKeys
		.Where(fk => table.Name.StartsWith(fk.ReferencedTable.Name))
		.Where(fk => table.Name != fk.ReferencedTable.Name)
		.OrderByDescending(fk => fk.ReferencedTable.Name.Length) // si plusieurs parents, on prend celui avec le nom le plus long
		.FirstOrDefault();
	return fkey;
}

/// <summary>
/// Extraction des colonnes route path suivant les ForeignKeys/enfants
/// </summary>
private List<Column> GetRouteColumns(Table table, bool recurseParents)
{
	List<Column> lstCols = new List<Column>();

	if (recurseParents)
    {
		FKey fkParent = GetParentFKey(table);
		if (fkParent != null)
		{
			Table parentTable = fkParent.ReferencedTable;

			List<Column> lst = GetRouteColumns(parentTable, recurseParents);
			lstCols.AddRange(lst);
		}
    }

	List<Column> parentCols = GetKeyColumns(table);
    if (parentCols != null)
	{
		lstCols.AddRange(parentCols);
    }

	return lstCols;
}

private string GetStrRoutePath(List<Column> lstCols, bool keepEnd = true, bool removeUselessCols = true)
{
	string strRoute = "";
	string currentTable = "";

	Column lastCol = lstCols.Last();
	Table tbl = lastCol.ParentTable;

	foreach (Column phCol in lstCols)
    {
		if (phCol.ParentTable.ClassName != currentTable)
        {
			string newTableName = phCol.ParentTable.ClassName.Remove(0, 3);
			if (currentTable != "")
            {
				newTableName = phCol.ParentTable.ClassName.Replace(currentTable, "");
            }
			strRoute += "/" + newTableName;

			currentTable = phCol.ParentTable.ClassName;
        }

		string strCol = "{" + phCol.PropertyName + "}";
		if (!strRoute.Contains(strCol))
        {
			if (removeUselessCols && lastCol.IsPKey && phCol != lastCol)
            {
				continue;
            }
			if (keepEnd || (phCol.ParentTable != tbl))
			{
				strRoute += "/";
				strRoute += strCol;
			}
        }
    }

	return strRoute;
}

private string GetResourceName(List<Column> lstCols)
{
	List<string> parts = new List<string>();

	string currentTable = "";
	foreach (Column phCol in lstCols)
    {
		if (phCol.ParentTable.ClassName != currentTable)
        {
			string newTableName = phCol.ParentTable.ClassName.Remove(0, 3);
			if (currentTable != "")
            {
				newTableName = phCol.ParentTable.ClassName.Replace(currentTable, "");
            }
			
			parts.Add(newTableName);

			currentTable = phCol.ParentTable.ClassName;
        }
    }
	
	if (parts.Count == 0)
    {
		return "";
    }
	else
    {
		string res = parts.Last();

		if (parts.Count == 1)
        {
			return res;
        }
		else
		{
			string parentRes = string.Join("/", parts.Where(p => p != res));
			return string.Format("{0} ({1})", res, parentRes);
        }
    }
}

private string GetConnectionString(Project project, string connectionStringName, out string providerName)
{
	providerName = null;
	string configPath = "";

	foreach (ProjectItem item in project.ProjectItems)
    {
		if (item.Name.Equals("App.config", StringComparison.OrdinalIgnoreCase) || item.Name.Equals("Web.config", StringComparison.OrdinalIgnoreCase))
		{
			string fullPath = project.Properties.Item("FullPath").Value.ToString();
			configPath = Path.Combine(fullPath, item.Name);
		}
    }
	
	string connStr = "";

	if (string.IsNullOrEmpty(configPath))
    {
		throw new ArgumentNullException("The project does not contain App.config or Web.config file.");
	}
	else
	{
		ExeConfigurationFileMap configFile = new ExeConfigurationFileMap();
		configFile.ExeConfigFilename = configPath;

		var config = System.Configuration.ConfigurationManager.OpenMappedExeConfiguration(configFile, ConfigurationUserLevel.None);
		var connSection = config.ConnectionStrings;

		// if the connectionString is empty - which is the defauls look for count-1 - this is the last connection string
		// and takes into account AppServices and LocalSqlServer
		if (string.IsNullOrEmpty(connectionStringName))
		{
			if (connSection.ConnectionStrings.Count > 1)
			{
				connectionStringName = connSection.ConnectionStrings[connSection.ConnectionStrings.Count - 1].Name;
			}
		}
		try
		{
			connStr = connSection.ConnectionStrings[connectionStringName].ConnectionString;
			providerName = connSection.ConnectionStrings[connectionStringName].ProviderName;
		}
		catch
		{
		}
	}

    return connStr;
}
#>