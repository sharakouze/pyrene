<#@ template language="C#" hostspecific="true" debug="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Configuration" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Configuration" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Linq" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\MultipleOutputHelper.ttinclude" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\VisualStudioHelper.ttinclude" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\SqlSchemaReader.ttinclude" #>
<#
	/***** TODO *****
	- DefaultAttribute
    - Alternative a TransformRoutePath avec des const
    - Commentaires sur les [References] ?
    - Ajout de propriétés [References] pour les FK ?
	- ResourceName
	****************/

	/*********************/
	/** CUSTOM SETTINGS **/
	/*********************/

	// chaine de connection pour l'extration du schéma
    string ConnectionStringName = "PyreneModel";
	string ConnectionString = "";

	// schema a extraire ou vide pour tous les schémas
	string SchemaName = "";

    // if true: Changes the classname to singular or plural.
    bool MakeSingular = false;
    bool MakePlural = false;

    // Namespace des fichiers générés.
	// {0} = DefaultNamespace du projet/répertoire courant.
    string NamespacePocos = "{0}.Types";
    string NamespaceMessages = "{0}";

    // true pour générer des classes partial.
    bool MakeClassesPartial = true;

    // true pour générer des propriétés virtual.
    bool MakePropertiesVirtual = false;

    // true pour générer chaque classe dans un fichier séparé.
    bool SplitIntoMultipleFiles = true;

    // if true: Changes the primary key property name to Id.
    bool UseIdAsPK = false;

    // if true: Adds explicit '[Schema]' attribute.
    bool UseSchemaAttribute = true;

    // if true: Adds References(typeof(ReferenceTableType)) to FKs.
    bool IncludeReferences = true;

    // true: Ajoute [Index] et [CompositeIndex].
    bool IncludeIndices = true;

    // Ajoute les interfaces IAuditable, etc...
    bool AddCustomInterfaces = true;

    // Ajoute des propriétés avec l'attribut [Reference] pour les tables enfants
    bool AddChildReferences = true;

    // Ajoute [ApiMember], [ApiAllowableValues]...
    bool AddApiAttributes = true;

    // true pour ajouter l'attribut [Route(...)] sur les classes générées.
    bool AddRouteAttributes = true;

    // true pour transformer la route de la ressource, ex: GenFournContact de '/GenFournContact/' en '/GenFourn/{xxx}/Contact/'.
    bool TransformRoutePath = true;

    // Filtre les messages générés.
    Regex PutTableFilterExclude = null;
    Regex PostTableFilterExclude = null;
	Regex GetTableFilterExclude = null;
	Regex DeleteTableFilterExclude = null;
	Regex PatchTableFilterExclude = null;
	Regex AutocompleteTableFilterExclude = null;

    // Si non null, méthode appliquée sur la collection des tables
    Action<Tables> TweakSchema = (tables) =>
    {	
		foreach (Table table in tables)
        {
			string stdColFormat = GetStandardColumnFormat(table);
			SetColumnsDescription(table, stdColFormat);
        }

		tables.RemoveAll(t => t.Name == "__RefactorLog");

		tables.ChangePropertyType("GenCompteur", "TypCompteur", "TypCompteur");
		tables.ChangePropertyType("GenCompteur", "TypPeriodicite", "TypPeriodicite");
		tables.ChangePropertyType("GenMandat", "TypMandat", "TypMandat");
		tables.ChangePropertyType("GenPersonne", "TypCivilite", "TypCivilite");
		tables.ChangePropertyType("GenFourn", "TypModeReglement", "TypModeReglement");
		tables.ChangePropertyType("GenFournContact", "TypCivilite", "TypCivilite");
    };

#>
<#
    Manager manager = Manager.Create(Host, GenerationEnvironment);
    manager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable 1591

<#
	manager.EndBlock(); // end header
    
    // Get a reference to the project of this t4 template
    Project project = VisualStudioHelper.CurrentProject;
	
	string fileNamespace = VisualStudioHelper.CurrentFileNamespace;

	// Contient tous les enums du projet
    List<string> allEnums = VisualStudioHelper.CodeModel.GetAllCodeElementsOfType(project.CodeModel.CodeElements, vsCMElement.vsCMElementEnum, false)
        .OfType<CodeEnum>()
		.Select(x => x.Name)
		.ToList();

	if (string.IsNullOrWhiteSpace(ConnectionString))
    {
		string providerName;
		ConnectionString = GetConnectionString(project, ConnectionStringName, out providerName);
    }
	
    // Read schema
    Tables allTables = LoadTables(ConnectionString, SchemaName, false, MakeSingular, MakePlural);
    if (TweakSchema != null)
    {
        TweakSchema(allTables);
    }

    foreach (Table table in allTables)
    {
        manager.StartNewFile(table.ClassName + ".generated.cs");

		string pocoNamespace = string.Format(NamespacePocos, fileNamespace);
#>
using System;
using System.Collections.Generic;
using System.Net;
using System.Runtime.Serialization;
using ServiceStack;
using ServiceStack.DataAnnotations;
using ServiceStack.Model;

namespace <#= pocoNamespace #>
{
<#
        List<string> lstInterfaces = new List<string>();

		if (table.PrimaryKey == null)
        {
			string errorMsg = string.Format("[{0}].[{1}] : La table est ignorée car elle n'a pas de clé primaire.",
				table.Schema, table.Name);
			Error(errorMsg);
#>
	// <#= errorMsg #>
<#
			continue;
        }
        else
        {
			if (table.PrimaryKey.PKeyColumns.Count > 1)
            {
				string errorMsg = string.Format("[{0}].[{1}].[{2}] : OrmLite ne supporte pas les clés primaires composites ; la table est ignorée.",
					table.Schema, table.Name, table.PrimaryKey.Name);
				Error(errorMsg);
#>
	// <#= errorMsg #>
<#
				continue;
            }

			Column pkCol = table.PrimaryKey.PKeyColumns.Single();
            if (UseIdAsPK)
            {
                pkCol.PropertyName = "Id";
            }
            if (pkCol.PropertyName == "Id")
            {
                lstInterfaces.Add("IHasId<" + pkCol.PropertyType + ">");
            }
        }
        if (AddCustomInterfaces)
        {
            if (table.Columns.Any(c => c.PropertyName == "DatCreation" && c.ProperPropertyType == "DateTime") &&
                table.Columns.Any(c => c.PropertyName == "DatModif" && c.ProperPropertyType == "DateTime"))
            {
                lstInterfaces.Add("IAuditable");
            }
        }

        if (table.ClassName != table.Name)
        {
#>
	[Alias("<#= table.Name #>")]
<#
        }
		
        if (UseSchemaAttribute && !string.IsNullOrEmpty(table.Schema) && table.Schema != "dbo")
        {
#>
	[Schema("<#= table.Schema #>")]
<#
        }
		
        if (IncludeIndices)
        {
			IEnumerable<TableIndex> compositeIdx = table.Indices.Where(i => i.IndexColumns.Count > 1);
            foreach (TableIndex idx in compositeIdx)
            {
				IEnumerable<string> q = idx.IndexColumns
					.Select(c => (c.Name == c.PropertyName) ? string.Format("nameof({0})", c.PropertyName) : string.Format("\"{0}\"", c.Name));
#>
	[CompositeIndex(<#= idx.IsUnique ? "true, " : "" #><#= string.Join(", ", q) #>)]
<#
            }
        }

		string resourceName = table.ClassName;

		List<Column> lstPlaceholderCols = GetRouteColumns(table, TransformRoutePath);

        bool putExcluded = PutTableFilterExclude != null && PutTableFilterExclude.IsMatch(table.ClassName);
        bool postExcluded = PostTableFilterExclude != null && PostTableFilterExclude.IsMatch(table.ClassName);

        if (AddRouteAttributes && (!putExcluded || !postExcluded))
        {
            if (!postExcluded)
            {
				string strRoute = BuildStrRoutePath(lstPlaceholderCols, false);
#>
    [Route("<#= strRoute #>", HttpVerbs.Post, Summary = "<#= string.Format("Ajoute une ressource {0}.", resourceName) #>")]
<#
            }
            if (!putExcluded)
            {
				string strRoute = BuildStrRoutePath(lstPlaceholderCols);
#>
    [Route("<#= strRoute #>", HttpVerbs.Put, Summary = "<#= string.Format("Remplace une ressource {0}.", resourceName) #>")]
<#
            }

            if (AddApiAttributes)
            {
#>
    [ApiResponse(HttpStatusCode.NotFound, "La ressource <#= resourceName #> spécifiée est introuvable.")]
<#
            }
        }
		
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= table.ClassName #><#= lstInterfaces.Any() ? " : " + string.Join(",\r\n\t\t", lstInterfaces) : "" #>
	{
<#
        foreach (Column col in table.Columns)
        {
            if (!string.IsNullOrWhiteSpace(col.Description))
            {
#>
		/// <summary>
		/// <#= col.Description #>
		/// </summary>
<#
			}
			if (col.Name != col.PropertyName)
			{
#>
        [Alias("<#= col.Name #>")]
<#
			}

			if (col.PropertyType == "string" && col.Size > 0)
			{   
#>
		[StringLength(<#= col.Size #>)]
<#
            }
            else if (col.PropertyType == "decimal" && col.Precision > 0)
            {
#>
		[DecimalLength(<#= col.Precision #>, <#= col.Scale #>)]
<#
            }

            if (col.IsAutoIncrement)
            {
#>
		[AutoIncrement]
<#
            }

            if (col.IsComputed)
            {
#>
		[Compute]        
<#
            }

            if (IncludeReferences)
            {
                FKey thisFKey = table.ForeignKeys.Where(fk => fk.FromColumns.Contains(col)).FirstOrDefault();
                if (thisFKey != null)
                {
                    if (string.IsNullOrEmpty(thisFKey.DeleteRule))
                    {
#>
		[References(typeof(<#= thisFKey.ReferencedTable.ClassName #>))]
<#
                    }
                    else
                    {
#>
		[ForeignKey(typeof(<#= thisFKey.ReferencedTable.ClassName #>), OnDelete = "<#= thisFKey.DeleteRule #>")]
<#
                    }
                }
            }

            if (col.IsNullable == false && col.IsAutoIncrement == false)
            {
#>
		[Required]
<#
            }

            if (IncludeIndices)
            {
				TableIndex index = table.Indices.Where(idx => idx.IndexColumns.Count == 1 && idx.IndexColumns.Contains(col)).FirstOrDefault();
                if (index != null)
                {
#>
		[Index<#= index.IsUnique ? "(true)" : "" #>]
<#
                }
            }

            if (col.IsPKey && (col.PropertyName != "Id"))
            {
#>
		[PrimaryKey]
<#
            }

			if (AddApiAttributes)
            {
				List<string> lstApiMemberProps = GetApiMemberProps(col, allEnums, lstInterfaces);
				if (lstApiMemberProps.Any())
                {
					if (col.IsPKey && (!putExcluded || !postExcluded))
					{
						if (!postExcluded)
						{
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>, Verb = HttpVerbs.Post)]
<#
						}
						if (!putExcluded)
						{
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>, Verb = HttpVerbs.Put, IsRequired = true, ParameterType = SwaggerParamTypes.Path)]
<#
						}
					}
					else
					{
						if (lstPlaceholderCols.Contains(col))
						{
							lstApiMemberProps.Add("ParameterType = SwaggerParamTypes.Path");
						}
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>)]
<#
					}
				}

                if (allEnums.Contains(col.PropertyType))
                {
#>
		[ApiAllowableValues(nameof(<#= col.PropertyName #>), typeof(<#= col.PropertyType #>))]
<#
                }

            }
#>
		public <#= MakePropertiesVirtual ? "virtual " : "" #><#= col.ProperPropertyType #> <#= col.PropertyName #> { get; set; }

<#
        } // end foreach (col)

        if (AddChildReferences)
        {
           var q = from tbl in allTables
					where tbl.Name.StartsWith(table.Name)
					from fk in tbl.ForeignKeys
					where fk.ReferencedTable == table
					let fkCol = fk.FromColumns.Single()
					let fkIsPK = tbl.PrimaryKey != null && tbl.PrimaryKey.PKeyColumns.Contains(fkCol)
					let fkIsUnique = tbl.Indices.Any(idx => idx.IsUnique && idx.IndexColumns.Count == 1 && idx.IndexColumns.Contains(fkCol))
					select new
					{
						Table = tbl,
						IsUnique = fkIsPK || fkIsUnique
					};
            foreach (var obj in q)
            {
                string propType = obj.Table.ClassName;
                string propName = obj.Table.ClassName.Replace(table.ClassName, "");
                if (!obj.IsUnique)
                {
                    propType = "List<" + propType + ">";
                    propName = "Lst" + propName;
                }
#>
		[Reference]
		public <#= MakePropertiesVirtual ? "virtual " : "" #><#= propType #> <#= propName #> { get; set; }

<#
            }
        }
#>
	}
}
<#
        manager.EndBlock(); // end newfile

		string msgNamespace = string.Format(NamespaceMessages, fileNamespace);

		/*******************/
		/** BEGIN GETBYID **/
		/*******************/

		bool getExcluded = GetTableFilterExclude != null && GetTableFilterExclude.IsMatch(table.ClassName);
		if (!getExcluded)
		{
			string getTableClassName = "Get" + table.ClassName;
			string getTableClassDescription = "Retourne une ressource {0}.";
			string fieldsPropDescription = "Champs à retourner, ou null pour retourner tous les champs.";

			manager.StartNewFile(getTableClassName + ".generated.cs");
#>
using System.Net;
using ServiceStack;
<#
			if (pocoNamespace != msgNamespace)
            {
#>
using <#= pocoNamespace #>;
<#
			}
#>

namespace <#= msgNamespace #>
{
	/// <summary>
	/// <#= string.Format(getTableClassDescription, "<see cref=\"" + table.ClassName + "\" />") #>
	/// </summary>
<#
            if (AddRouteAttributes)
            {
				string strRoute = BuildStrRoutePath(lstPlaceholderCols);
#>
	[Route("<#= strRoute #>", HttpVerbs.Get, Summary = "<#= string.Format(getTableClassDescription, resourceName) #>")]
<#
			    if (AddApiAttributes)
                {
#>
    [ApiResponse(HttpStatusCode.BadRequest, "La ressource <#= resourceName #> ne contient pas tous les champs demandés.")]
    [ApiResponse(HttpStatusCode.NotFound, "La ressource <#= resourceName #> spécifiée est introuvable.")]
<#
                }
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= getTableClassName #> : IReturn<<#= table.ClassName #>>
	{
<#
		foreach (Column phCol in lstPlaceholderCols)
		{
			if (!string.IsNullOrWhiteSpace(phCol.Description))
            {
#>
        /// <summary>
        /// <#= phCol.Description #>
        /// </summary>
<#
            }
			if (AddApiAttributes)
            {
				List<string> lstApiMemberProps = GetApiMemberProps(phCol, allEnums, lstInterfaces);
				lstApiMemberProps.Add("ParameterType = SwaggerParamTypes.Path");
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>)]
<#
            }
#>
        public <#= phCol.ProperPropertyType #> <#= phCol.PropertyName #> { get; set; }

<#
		}
#>
        /// <summary>
        /// <#= fieldsPropDescription #>
        /// </summary>
<#
			    if (AddApiAttributes)
                {
#>
        [ApiMember(Description = "<#= fieldsPropDescription #>", DataType = SwaggerDataTypes.ArrayOfString)]
<#
                }
#>
        public string[] Fields { get; set; }
	}
}
<#
			manager.EndBlock(); // end newfile
		}

		/**********************/
		/** BEGIN DELETEBYID **/
		/**********************/

		bool deleteExcluded = DeleteTableFilterExclude != null && DeleteTableFilterExclude.IsMatch(table.ClassName);
		if (!deleteExcluded)
		{
			string deleteTableClassName = "Delete" + table.ClassName;
			string deleteTableClassDescription = "Supprime une ressource {0}.";

			manager.StartNewFile(deleteTableClassName + ".generated.cs");
#>
using System.Net;
using ServiceStack;
<#
			if (pocoNamespace != msgNamespace)
            {
#>
using <#= pocoNamespace #>;
<#
			}
#>

namespace <#= msgNamespace #>
{
	/// <summary>
	/// <#= string.Format(deleteTableClassDescription, "<see cref=\"" + table.ClassName + "\" />") #>
	/// </summary>
<#
            if (AddRouteAttributes)
            {
				string strRoute = BuildStrRoutePath(lstPlaceholderCols);
#>
	[Route("<#= strRoute #>", HttpVerbs.Delete, Summary = "<#= string.Format(deleteTableClassDescription, resourceName) #>")]
<#
			    if (AddApiAttributes)
                {
#>
    [ApiResponse(HttpStatusCode.NotFound, "La ressource <#= resourceName #> spécifiée est introuvable.")]
<#
                }
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= deleteTableClassName #> : IReturnVoid
	{
<#
		foreach (Column phCol in lstPlaceholderCols)
		{
			if (!string.IsNullOrWhiteSpace(phCol.Description))
            {
#>
        /// <summary>
        /// <#= phCol.Description #>
        /// </summary>
<#
            }
			if (AddApiAttributes)
            {
				List<string> lstApiMemberProps = GetApiMemberProps(phCol, allEnums, lstInterfaces);
				lstApiMemberProps.Add("ParameterType = SwaggerParamTypes.Path");
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>)]
<#
            }
#>
        public <#= phCol.ProperPropertyType #> <#= phCol.PropertyName #> { get; set; }

<#
		}
#>
	}
}
<#
			manager.EndBlock(); // end newfile
		}

		/*********************/
		/** BEGIN PATCHBYID **/
		/*********************/

		bool patchExcluded = PatchTableFilterExclude != null && PatchTableFilterExclude.IsMatch(table.ClassName);
		if (!patchExcluded)
		{
			string patchTableClassName = "Patch" + table.ClassName;
			string patchTableClassDescription = "Modifie partiellement une ressource {0}.";
			string fieldsPropDescription = "Liste des modifications.";

			manager.StartNewFile(patchTableClassName + ".generated.cs");
#>
using System.Net;
using ServiceStack;
<#
			if (pocoNamespace != msgNamespace)
            {
#>
using <#= pocoNamespace #>;
<#
			}
#>

namespace <#= msgNamespace #>
{
	/// <summary>
	/// <#= string.Format(patchTableClassDescription, "<see cref=\"" + table.ClassName + "\" />") #>
	/// </summary>
<#
            if (AddRouteAttributes)
            {
				string strRoute = BuildStrRoutePath(lstPlaceholderCols);
#>
	[Route("<#= strRoute #>", HttpVerbs.Patch, Summary = "<#= string.Format(patchTableClassDescription, resourceName) #>")]
<#
			    if (AddApiAttributes)
                {
#>
    [ApiResponse(HttpStatusCode.BadRequest, "La ressource <#= resourceName #> ne contient pas tous les champs demandés.")]
    [ApiResponse(HttpStatusCode.NotFound, "La ressource <#= resourceName #> spécifiée est introuvable.")]
<#
                }
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= patchTableClassName #> : IReturnVoid
	{
<#
		foreach (Column phCol in lstPlaceholderCols)
		{
			if (!string.IsNullOrWhiteSpace(phCol.Description))
            {
#>
        /// <summary>
        /// <#= phCol.Description #>
        /// </summary>
<#
            }
			if (AddApiAttributes)
            {
				List<string> lstApiMemberProps = GetApiMemberProps(phCol, allEnums, lstInterfaces);
				lstApiMemberProps.Add("ParameterType = SwaggerParamTypes.Path");
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>)]
<#
            }
#>
        public <#= phCol.ProperPropertyType #> <#= phCol.PropertyName #> { get; set; }

<#
		}
#>
        /// <summary>
        /// <#= fieldsPropDescription #>
        /// </summary>
<#
			    if (AddApiAttributes)
                {
#>
        [ApiMember(Description = "<#= fieldsPropDescription #>", DataType = "Array[" + nameof(Patch) + "]", IsRequired = true, ParameterType = SwaggerParamTypes.Form)]
<#
                }
#>
        public Patch[] Fields { get; set; }
	}
}
<#
			manager.EndBlock(); // end newfile
		}

		string stdColFormat = GetStandardColumnFormat(table);
		bool hasCodObjet = table.Columns.Any(c => c.PropertyType == "string" && c.PropertyName == string.Format(stdColFormat, "Cod"));
		bool hasLibObjet = table.Columns.Any(c => c.PropertyType == "string" && c.PropertyName == string.Format(stdColFormat, "Lib"));
		bool hasEstActif = table.Columns.Any(c => c.PropertyType == "bool" && c.PropertyName == "EstActif");

		if (hasCodObjet && hasLibObjet && hasEstActif)
        {
			/************************/
			/** BEGIN AUTOCOMPLETE **/
			/************************/

			bool autocompleteExcluded = AutocompleteTableFilterExclude != null && AutocompleteTableFilterExclude.IsMatch(table.ClassName);
			if (!autocompleteExcluded)
			{
				var autocompleteClassName = "Autocomplete" + table.ClassName;
				var autocompleteDescription = "Retourne des prédictions sur les ressources {0}.";
				var textPropDescription = "Texte à rechercher.";
				var maxPropDescription = "Nombre maximum de prédictions à retourner.";

				manager.StartNewFile(autocompleteClassName + ".generated.cs");
#>
using System.Net;
using ServiceStack;
<#
			if (pocoNamespace != msgNamespace)
            {
#>
using <#= pocoNamespace #>;
<#
			}
#>

namespace <#= msgNamespace #>
{
	/// <summary>
	/// <#= string.Format(autocompleteDescription, "<see cref=\"" + table.ClassName + "\" />") #>
	/// </summary>
<#
			if (AddRouteAttributes)
            {
				string strRouteBase = BuildStrRoutePath(lstPlaceholderCols, false);
#>
	[Route("<#= strRouteBase #>/Autocomplete/{Text}", HttpVerbs.Get, Summary = "<#= string.Format(autocompleteDescription, table.ClassName) #>")]
<#
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= autocompleteClassName #> : IReturn<BasicEntity[]>
	{
        /// <summary>
        /// <#= textPropDescription #>
        /// </summary>
<#
			    if (AddApiAttributes)
                {
#>
        [ApiMember(Description = "<#= textPropDescription #>", DataType = SwaggerDataTypes.String, IsRequired = true, ParameterType = SwaggerParamTypes.Path)]
<#
                }
#>
        public string Text { get; set; }

        /// <summary>
        /// <#= maxPropDescription #>
        /// </summary>
<#
			    if (AddApiAttributes)
                {
#>
        [ApiMember(Description = "<#= maxPropDescription #>", DataType = SwaggerDataTypes.Int)]
<#
                }
#>
        public int Max { get; set; }
	}
}
<#
				manager.EndBlock(); // end newfile
            }
        }
    } // end foreach (table)
	
    manager.Process(SplitIntoMultipleFiles);
#>
<#+
/// <summary>
/// Retourne une chaine qui représente le format que doit avoir une colonne standard (CodObjet, LibObjet, TxtObjet...) dans une table.
/// Exemple : GenService => "{0}Service" ; GenPersonneProfil => "{0}Profil" ...
/// </summary>
private string GetStandardColumnFormat(Table table)
{
	FKey parentFkey = GetParentFKey(table);
	if (parentFkey != null)
	{
		return parentFkey.FromTable.ClassName.Replace(parentFkey.ReferencedTable.ClassName, "{0}");
	}
	return "{0}" + table.Name.Remove(0, 3);
}

private void SetColumnsDescription(Table table, string stdColFormat)
{
	foreach (Column col in table.Columns)
    {
		if (string.IsNullOrWhiteSpace(col.Description))
        {
			if (col.IsPKey)
			{
				col.Description = "Clé primaire.";
			}
			else if (col.PropertyName == string.Format(stdColFormat, "Cod"))
			{
				col.Description = "Code.";
			}
			else if (col.PropertyName == string.Format(stdColFormat, "Lib"))
			{
				col.Description = "Désignation.";
			}
			else if (col.PropertyName == string.Format(stdColFormat, "Txt"))
			{
				col.Description = "Commentaire ou description.";
			}
			else
			{
				switch (col.PropertyName)
				{
					case "EstActif":
						col.Description = "Actif ou inactif.";
						break;
					case "DatCreation":
						col.Description = "Date de création. Immutable.";
						break;
					case "DatModif":
						col.Description = "Date de dernière modification. Immutable.";
						break;
					case "CodExterne":
						col.Description = "Identifiant de synchronisation externe.";
						break;

					case "NumTelep":
						col.Description = "Numéro de téléphone.";
						break;
					case "NumFax":
						col.Description = "Numéro de fax.";
						break;
					case "NumEmail":
						col.Description = "Adresse email.";
						break;

					case "AdrRue":
						col.Description = "Rue.";
						break;
					case "AdrCode":
						col.Description = "Code postal.";
						break;
					case "AdrCommune":
						col.Description = "Ville ou commune.";
						break;
					case "AdrPays":
						col.Description = "Pays.";
						break;
				}
			}
        }
		else if (!col.Description.EndsWith("."))
		{
			col.Description += ".";
		}

		if (col.IsAutoIncrement || col.IsComputed)
        {
			string desc = col.Description + " Immutable.";
			col.Description = desc.Trim();
        }
		bool isUniqueSingleCol = table.Indices
			.Where(idx => idx.IsUnique == true && idx.IndexColumns.Count == 1 && idx.IndexColumns.Contains(col))
			.Any();
		if (isUniqueSingleCol)
        {
			string desc = col.Description + " Unique.";
			col.Description = desc.Trim();
        }
    }
}

private List<string> GetApiMemberProps(Column col, List<string> lstEnums, List<string> lstInterfaces)
{
    List<string> lstApiMemberProps = new List<string>();

    if (!string.IsNullOrEmpty(col.Description))
    {
        lstApiMemberProps.Add("Description = \"" + col.Description + "\"");
    }
                
    string swagDataType = "";

    if (lstEnums.Contains(col.PropertyType))
    {
        //swagDataType = "SwaggerDataTypes.String";
    }
    else if (col.PropertyType == "byte[]")
    {
        swagDataType = "SwaggerDataTypes.File";
    }
    else
    {
        swagDataType = "SwaggerDataTypes." + col.PropertyType.Substring(0,1).ToUpper() + col.PropertyType.Substring(1);
    }

    if (!string.IsNullOrEmpty(swagDataType))
    {
        lstApiMemberProps.Add("DataType = " + swagDataType);
    }

    if (!col.IsPKey)
    {
        if (col.IsNullable == false && col.IsAutoIncrement == false)
        {
            bool required = true;
            if (lstInterfaces.Contains("IAuditable") && (col.ProperPropertyType == "DateTime")
                && (col.PropertyName == "DatCreation" || col.PropertyName == "DatModif"))
            {
                required = false;
            }
            if (required)
            {
                lstApiMemberProps.Add("IsRequired = true");
            }
        }
    }

	return lstApiMemberProps;
}

/// <summary>
/// Retourne les colonnes qui identifient la ressource.
/// </summary>
private List<Column> GetKeyColumns(Table table)
{
	if (table.PrimaryKey != null)
    {
		return table.PrimaryKey.PKeyColumns;
    }
	return null;
}

/// <summary>
/// Retourne la FK pointant sur la table parent la plus proche avec un nom similaire.
/// </summary>
private FKey GetParentFKey(Table table)
{
    // si plusieurs parents, on prend celui avec le nom le plus long
    FKey fkey = table.ForeignKeys
		.Where(fk => table.Name.StartsWith(fk.ReferencedTable.Name))
		.OrderByDescending(fk => fk.ReferencedTable.Name.Length)
		.FirstOrDefault();
	return fkey;
}

/// <summary>
/// Extraction des colonnes route path suivant les ForeignKeys/enfants
/// </summary>
private List<Column> GetRouteColumns(Table table, bool recurseParents)
{
	List<Column> lstCols = new List<Column>();

	if (recurseParents)
    {
		FKey fkParent = GetParentFKey(table);
		if (fkParent != null)
		{
			Table parentTable = fkParent.ReferencedTable;

			List<Column> lst = GetRouteColumns(parentTable, recurseParents);
			lstCols.AddRange(lst);
		}
    }

	List<Column> parentCols = GetKeyColumns(table);
    if (parentCols != null)
	{
		foreach (Column pCol in parentCols)
        {
			bool add = true;
			// on ajoute pas la colonne si elle est ajouté précedement
			FKey fkCol = table.ForeignKeys.FirstOrDefault(f => f.FromColumns.Contains(pCol));
			if (fkCol != null)
            {
				if (lstCols.Select(c => c.ParentTable).Any(t => t == fkCol.ReferencedTable))
                {
					add = false;
                }
            }
			if (add)
            {
				lstCols.Add(pCol);
            }
        }
    }

	return lstCols;
}

private string BuildStrRoutePath(List<Column> lstCols, bool keepEnd = true)
{
	string strRoute = "";
	string currentTable = "";

	Column lastCol = lstCols.Last();
	Table tbl = lastCol.ParentTable;

	foreach (Column phCol in lstCols)
    {
		if (phCol.ParentTable.ClassName != currentTable)
        {
			string newTableName = phCol.ParentTable.ClassName.Remove(0, 3);
			if (currentTable != "")
            {
				newTableName = phCol.ParentTable.ClassName.Replace(currentTable, "");
            }
			strRoute += "/" + newTableName;

			currentTable = phCol.ParentTable.ClassName;
        }

		if (keepEnd || (phCol.ParentTable != tbl))
        {
			strRoute += "/";
			strRoute += "{" + phCol.PropertyName + "}";
        }
    }

	return strRoute;
}

private string GetConnectionString(Project project, string connectionStringName, out string providerName)
{
	providerName = null;
	string configPath = "";

	foreach (ProjectItem item in project.ProjectItems)
    {
		if (item.Name.Equals("App.config", StringComparison.OrdinalIgnoreCase) || item.Name.Equals("Web.config", StringComparison.OrdinalIgnoreCase))
		{
			string fullPath = project.Properties.Item("FullPath").Value.ToString();
			configPath = Path.Combine(fullPath, item.Name);
		}
    }
	
	string connStr = "";

	if (string.IsNullOrEmpty(configPath))
    {
		throw new ArgumentNullException("The project does not contain App.config or Web.config file.");
	}
	else
	{
		ExeConfigurationFileMap configFile = new ExeConfigurationFileMap();
		configFile.ExeConfigFilename = configPath;

		var config = System.Configuration.ConfigurationManager.OpenMappedExeConfiguration(configFile, ConfigurationUserLevel.None);
		var connSection = config.ConnectionStrings;

		// if the connectionString is empty - which is the defauls look for count-1 - this is the last connection string
		// and takes into account AppServices and LocalSqlServer
		if (string.IsNullOrEmpty(connectionStringName))
		{
			if (connSection.ConnectionStrings.Count > 1)
			{
				connectionStringName = connSection.ConnectionStrings[connSection.ConnectionStrings.Count - 1].Name;
			}
		}
		try
		{
			connStr = connSection.ConnectionStrings[connectionStringName].ConnectionString;
			providerName = connSection.ConnectionStrings[connectionStringName].ProviderName;
		}
		catch
		{
		}
	}

    return connStr;
}
#>