<#@ template language="C#" hostspecific="true" debug="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="EnvDTE.dll" #>
<#@ assembly name="System.Core.dll" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Linq" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\MultipleOutputHelper.ttinclude" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\VisualStudioHelper.ttinclude" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\SqlSchemaReader.ttinclude" #>
<#
	/***** TODO *****
	- ConfigurationManager pour la connectionstring
	- DefaultAttribute
    - Alternative a TransformRoutePath avec des const
    - Commentaires sur les [References] ?
    - Ajout de propriétés [References] pour les FK ?
	- ResourceName
	****************/

	/*********************/
	/** CUSTOM SETTINGS **/
	/*********************/

	// chaine de connection pour l'extration du schéma
    string ConnectionString = @"Server=(LocalDB)\MSSQLLocalDB;Database=TMPI_PYRENE;Integrated Security=True;MultipleActiveResultSets=True";

	// schema a extraire ou vide pour tous les schémas
	string SchemaName = "";

    // if true: Changes the classname to singular or plural.
    bool MakeSingular = false;
    bool MakePlural = false;

    // Namespace des fichiers générés.
	// {0} = DefaultNamespace du projet/répertoire courant.
    string NamespacePocos = "{0}.Types";
    string NamespaceMessages = "{0}";

    // true pour générer des classes partial.
    bool MakeClassesPartial = true;

    // true pour générer des propriétés virtual.
    bool MakePropertiesVirtual = false;

    // true pour générer chaque classe dans un fichier séparé.
    bool SplitIntoMultipleFiles = true;

    // if true: Changes the primary key property name to Id.
    bool UseIdAsPK = false;

    // if true: Adds explicit '[Schema]' attribute.
    bool UseSchemaAttribute = true;

    // if true: Adds References(typeof(ReferenceTableType)) to FKs.
    bool IncludeReferences = true;

    // true: Ajoute [Index] et [CompositeIndex].
    bool IncludeIndices = true;

    // Ajoute les interfaces IAuditable, etc...
    bool AddCustomInterfaces = true;

    // Ajoute des propriétés avec l'attribut [Reference] pour les tables enfants
    bool AddChildReferences = true;

    // Ajoute [ApiMember], [ApiAllowableValues]...
    bool AddApiAttributes = true;

    // true pour ajouter l'attribut [Route(...)] sur les classes générées.
    bool AddRouteAttributes = true;

    // true pour transformer la route de la ressource, ex: GenFournContact de '/GenFournContact/' en '/GenFourn/{xxx}/Contact/'.
    bool TransformRoutePath = true;

	// false pour preferer l'utilisation des contraintes d'unicité plutot que les PK pour identifier les ressources.
    bool UsePKAsRouteId = false;

    // Filtre les messages générés.
    Regex PutTableFilterExclude = null;
    Regex PostTableFilterExclude = null;
	Regex GetTableFilterExclude = null;
	Regex DeleteTableFilterExclude = null;
	Regex PatchTableFilterExclude = null;
	Regex AutocompleteTableFilterExclude = null;

    // Si non null, méthode appliquée sur la collection des tables
    Action<Tables> TweakSchema = (tables) =>
    {	
		foreach (Table table in tables)
        {
			string stdColFormat = GetStandardColumnFormat(table);
			SetColumnsDescription(table, stdColFormat);
        }

		tables.RemoveAll(t => t.Name == "__RefactorLog");

		tables.ChangePropertyType("GenCompteur", "TypCompteur", "TypCompteur");
		tables.ChangePropertyType("GenCompteur", "TypPeriodicite", "TypPeriodicite");
		tables.ChangePropertyType("GenMandat", "TypMandat", "TypMandat");
		tables.ChangePropertyType("GenPersonne", "TypCivilite", "TypCivilite");
		tables.ChangePropertyType("GenFourn", "TypModeReglement", "TypModeReglement");
		tables.ChangePropertyType("GenFournContact", "TypCivilite", "TypCivilite");
    };

#>
<#
    Manager manager = Manager.Create(Host, GenerationEnvironment);
    manager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable 1591

<#
	manager.EndBlock(); // end header
    
    // Get a reference to the project of this t4 template
    Project project = VisualStudioHelper.CurrentProject;
	
	string fileNamespace = VisualStudioHelper.CurrentFileNamespace;

	// Contient tous les enums du projet
    List<string> allEnums = VisualStudioHelper.CodeModel.GetAllCodeElementsOfType(project.CodeModel.CodeElements, vsCMElement.vsCMElementEnum, false)
        .OfType<CodeEnum>()
		.Select(x => x.Name)
		.ToList();

    // Read schema
    Tables allTables = LoadTables(ConnectionString, SchemaName, false, MakeSingular, MakePlural);
    if (TweakSchema != null)
    {
        TweakSchema(allTables);
    }

    foreach (Table table in allTables)
    {
        manager.StartNewFile(table.ClassName + ".generated.cs");

		string pocoNamespace = string.Format(NamespacePocos, fileNamespace);
#>
using System;
using System.Collections.Generic;
using System.Net;
using System.Runtime.Serialization;
using ServiceStack;
using ServiceStack.DataAnnotations;
using ServiceStack.Model;

namespace <#= pocoNamespace #>
{
<#
        List<string> lstInterfaces = new List<string>();

		if (table.PrimaryKey == null)
        {
			string errorMsg = string.Format("[{0}].[{1}] : La table est ignorée car elle n'a pas de clé primaire.",
				table.Schema, table.Name);
			Error(errorMsg);
#>
	// <#= errorMsg #>
<#
			continue;
        }
        else
        {
			if (table.PrimaryKey.PKeyColumns.Count > 1)
            {
				string errorMsg = string.Format("[{0}].[{1}].[{2}] : OrmLite ne supporte pas les clés primaires composites ; la table est ignorée.",
					table.Schema, table.Name, table.PrimaryKey.Name);
				Error(errorMsg);
#>
	// <#= errorMsg #>
<#
				continue;
            }

			Column pkCol = table.PrimaryKey.PKeyColumns.Single();
            if (UseIdAsPK)
            {
                pkCol.PropertyName = "Id";
            }
            if (pkCol.PropertyName == "Id")
            {
                lstInterfaces.Add("IHasId<" + pkCol.PropertyType + ">");
            }
        }
        if (AddCustomInterfaces)
        {
            if (table.Columns.Any(c => c.PropertyName == "DatCreation" && c.ProperPropertyType == "DateTime") &&
                table.Columns.Any(c => c.PropertyName == "DatModif" && c.ProperPropertyType == "DateTime"))
            {
                lstInterfaces.Add("IAuditable");
            }
        }

        if (table.ClassName != table.Name)
        {
#>
	[Alias("<#= table.Name #>")]
<#
        }
		
        if (UseSchemaAttribute && !string.IsNullOrEmpty(table.Schema) && table.Schema != "dbo")
        {
#>
	[Schema("<#= table.Schema #>")]
<#
        }
		
        if (IncludeIndices)
        {
			IEnumerable<TableIndex> compositeIdx = table.Indices.Where(i => i.IndexColumns.Count > 1);
            foreach (TableIndex idx in compositeIdx)
            {
				IEnumerable<string> q = idx.IndexColumns
					.Select(c => (c.Name == c.PropertyName) ? string.Format("nameof({0})", c.PropertyName) : string.Format("\"{0}\"", c.Name));
#>
	[CompositeIndex(<#= idx.IsUnique ? "true, " : "" #><#= string.Join(", ", q) #>)]
<#
            }
        }

		string resourceName = table.ClassName;

	    List<Column> lstKeyCols = GetBestUniqueColumns(table, UsePKAsRouteId);
		List<Column> lstPlaceholderCols = new List<Column>();

		List<string> lstRouteBaseParts = new List<string>(new [] { table.ClassName });
	    List<string> lstRouteKeyParts = lstKeyCols.Select(c => c.PropertyName).ToList();

        if (AddRouteAttributes && TransformRoutePath)
        {
            lstRouteBaseParts = GetRoutePartsFromTable(table, UsePKAsRouteId, ref lstPlaceholderCols);

			FKey parentFKey = GetParentFKey(table);
			if (parentFKey != null)
            {
				lstRouteKeyParts.RemoveAll(str => parentFKey.FromColumns.Any(c => c.PropertyName == str));
            }
        }

		lstPlaceholderCols.AddRange(table.Columns.Where(c => lstRouteKeyParts.Contains(c.PropertyName)));
		lstRouteKeyParts = lstRouteKeyParts.Select(c => "{" + c + "}").ToList();

        bool putExcluded = PutTableFilterExclude != null && PutTableFilterExclude.IsMatch(table.ClassName);
        bool postExcluded = PostTableFilterExclude != null && PostTableFilterExclude.IsMatch(table.ClassName);

        if (AddRouteAttributes && (!putExcluded || !postExcluded))
        {
			string strRouteBase = "/" + string.Join("/", lstRouteBaseParts);
			string strRouteKey = "/" + string.Join("/", lstRouteKeyParts);

            if (!postExcluded)
            {
				string strRouteKeyPost = strRouteKey;
				bool routeKeyIsReadonly = lstKeyCols.Any(c => c.IsAutoIncrement || c.IsComputed);
                if (routeKeyIsReadonly)
                {
                    strRouteKeyPost = "";
                }
#>
    [Route("<#= strRouteBase #><#= strRouteKeyPost #>", HttpVerbs.Post, Summary = "<#= string.Format("Ajoute une ressource '{0}'.", resourceName) #>")]
<#
            }
            if (!putExcluded)
            {
#>
    [Route("<#= strRouteBase #><#= strRouteKey #>", HttpVerbs.Put, Summary = "<#= string.Format("Remplace une ressource '{0}'.", resourceName) #>")]
<#
            }

            if (AddApiAttributes)
            {
#>
    [ApiResponse(HttpStatusCode.NotFound, "La ressource '<#= resourceName #>' spécifiée est introuvable.")]
<#
            }
        }
		
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= table.ClassName #><#= lstInterfaces.Any() ? " : " + string.Join(",\r\n\t\t", lstInterfaces) : "" #>
	{
<#
        foreach (Column col in table.Columns)
        {
            if (!string.IsNullOrWhiteSpace(col.Description))
            {
#>
		/// <summary>
		/// <#= col.Description #>
		/// </summary>
<#
			}
			if (col.Name != col.PropertyName)
			{
#>
        [Alias("<#= col.Name #>")]
<#
			}

			if (col.PropertyType == "string" && col.Size > 0)
			{   
#>
		[StringLength(<#= col.Size #>)]
<#
            }
            else if (col.PropertyType == "decimal" && col.Precision > 0)
            {
#>
		[DecimalLength(<#= col.Precision #>, <#= col.Scale #>)]
<#
            }

            if (col.IsAutoIncrement)
            {
#>
		[AutoIncrement]
<#
            }

            if (col.IsComputed)
            {
#>
		[Compute]        
<#
            }

            if (IncludeReferences)
            {
                FKey thisFKey = table.ForeignKeys.Where(fk => fk.FromColumns.Contains(col)).FirstOrDefault();
                if (thisFKey != null)
                {
                    if (string.IsNullOrEmpty(thisFKey.DeleteRule))
                    {
#>
		[References(typeof(<#= thisFKey.ReferencedTable.ClassName #>))]
<#
                    }
                    else
                    {
#>
		[ForeignKey(typeof(<#= thisFKey.ReferencedTable.ClassName #>), OnDelete = "<#= thisFKey.DeleteRule #>")]
<#
                    }
                }
            }

            if (col.IsNullable == false && col.IsAutoIncrement == false)
            {
#>
		[Required]
<#
            }

            if (IncludeIndices)
            {
				TableIndex index = table.Indices.Where(idx => idx.IndexColumns.Count == 1 && idx.IndexColumns.Contains(col)).FirstOrDefault();
                if (index != null)
                {
#>
		[Index<#= index.IsUnique ? "(true)" : "" #>]
<#
                }
            }

            if (col.IsPKey && (col.PropertyName != "Id"))
            {
#>
		[PrimaryKey]
<#
            }

            bool dataMemberIgnored = false;
            if (!UsePKAsRouteId) 
            {
				dataMemberIgnored = (col.IsPKey || col.IsFKey);
            }

            if (dataMemberIgnored)
            {
#>
        [IgnoreDataMember]
<#
            }
            else if (AddApiAttributes)
            {
				List<string> lstApiMemberProps = GetApiMemberProps(col, allEnums, lstInterfaces);
				if (lstApiMemberProps.Any())
                {
					if (col.IsPKey && (!putExcluded || !postExcluded))
					{
						if (!postExcluded)
						{
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>, Verb = HttpVerbs.Post)]
<#
						}
						if (!putExcluded)
						{
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>, Verb = HttpVerbs.Put, IsRequired = true, ParameterType = SwaggerParamTypes.Path)]
<#
						}
					}
					else
					{
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>)]
<#
					}
				}

                if (allEnums.Contains(col.PropertyType))
                {
#>
		[ApiAllowableValues(nameof(<#= col.PropertyName #>), typeof(<#= col.PropertyType #>))]
<#
                }

            }
#>
		public <#= MakePropertiesVirtual ? "virtual " : "" #><#= col.ProperPropertyType #> <#= col.PropertyName #> { get; set; }

<#
			if (!UsePKAsRouteId)
            {
				FKey thisFkey = table.ForeignKeys.Where(fk => fk.FromColumns.Contains(col)).FirstOrDefault();
                if (thisFkey != null)
				{
					Column fkFromCol = thisFkey.FromColumns.Single();
					Column fkRefCol = thisFkey.ReferencedColumns.Single();

					string format = GetFKeyColumnFormat(thisFkey);

					List<Column> lstNewFkCols = GetBestUniqueColumns(fkRefCol.ParentTable, UsePKAsRouteId);
					foreach (Column fkCol in lstNewFkCols)
                    { 
						Column newCol = fkCol.Clone();
						newCol.IsNullable = fkFromCol.IsNullable;
						string newDescription = fkFromCol.Description + " " + newCol.Description;
						newCol.Description = newDescription.Trim();
						newCol.PropertyName = string.Format(format, newCol.PropertyName);

						if (!string.IsNullOrEmpty(newCol.Description))
                        {
#>
		/// <summary>
		/// <#= newCol.Description #>
		/// </summary>
<#
						}
#>
        /// <remarks>
		/// Remplace la propriété <see cref="<#= col.PropertyName #>" /> dans la sérialisation.
		/// Référence la propriété <see cref="<#= fkCol.ParentTable.ClassName #>.<#= fkCol.PropertyName #>" />.
        /// </remarks>
<#
						if (AddApiAttributes)
						{
							List<string> lstApiMemberProps = GetApiMemberProps(newCol, allEnums, lstInterfaces);
							if (lstApiMemberProps.Any())
							{
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>)]
<#
							}
						}
#>
		[Ignore]
		public <#= MakePropertiesVirtual ? "virtual " : "" #><#= newCol.ProperPropertyType #> <#= newCol.PropertyName #> { get; set; }

<#
					}
				}
            }
        } // end foreach (col)

        if (AddChildReferences)
        {
           var q = from tbl in allTables
					where tbl.Name.StartsWith(table.Name)
					from fk in tbl.ForeignKeys
					where fk.ReferencedTable == table
					let fkCol = fk.FromColumns.Single()
					let fkIsPK = tbl.PrimaryKey != null && tbl.PrimaryKey.PKeyColumns.Contains(fkCol)
					let fkIsUnique = tbl.Indices.Any(idx => idx.IsUnique && idx.IndexColumns.Count == 1 && idx.IndexColumns.Contains(fkCol))
					select new
					{
						Table = tbl,
						IsUnique = fkIsPK || fkIsUnique
					};
            foreach (var obj in q)
            {
                string propType = obj.Table.ClassName;
                string propName = obj.Table.ClassName.Replace(table.ClassName, "");
                if (!obj.IsUnique)
                {
                    propType = "List<" + propType + ">";
                    propName = "Lst" + propName;
                }
#>
		[Reference]
		public <#= MakePropertiesVirtual ? "virtual " : "" #><#= propType #> <#= propName #> { get; set; }

<#
            }
        }
#>
	}
}
<#
        manager.EndBlock(); // end newfile

		string msgNamespace = string.Format(NamespaceMessages, fileNamespace);

		/*******************/
		/** BEGIN GETBYID **/
		/*******************/

		bool getExcluded = GetTableFilterExclude != null && GetTableFilterExclude.IsMatch(table.ClassName);
		if (!getExcluded)
		{
			string getTableClassName = "Get" + table.ClassName;
			string getTableClassDescription = "Retourne une ressource {0}.";
			string fieldsPropDescription = "Champs à retourner, ou null pour retourner tous les champs.";

			manager.StartNewFile(getTableClassName + ".generated.cs");
#>
using System.Net;
using ServiceStack;
<#
			if (pocoNamespace != msgNamespace)
            {
#>
using <#= pocoNamespace #>;
<#
			}
#>

namespace <#= msgNamespace #>
{
	/// <summary>
	/// <#= string.Format(getTableClassDescription, "<see cref=\"" + table.ClassName + "\" />") #>
	/// </summary>
<#
            if (AddRouteAttributes)
            {
				string strRouteBase = "/" + string.Join("/", lstRouteBaseParts);
				string strRouteKey = "/" + string.Join("/", lstRouteKeyParts);
#>
	[Route("<#= strRouteBase #><#= strRouteKey #>", HttpVerbs.Get, Summary = "<#= string.Format(getTableClassDescription, "'" + resourceName + "'") #>")]
<#
			    if (AddApiAttributes)
                {
#>
    [ApiResponse(HttpStatusCode.BadRequest, "La ressource '<#= resourceName #>' ne contient pas tous les champs demandés.")]
    [ApiResponse(HttpStatusCode.NotFound, "La ressource '<#= resourceName #>' spécifiée est introuvable.")]
<#
                }
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= getTableClassName #> : IReturn<<#= table.ClassName #>>
	{
<#
		foreach (Column phCol in lstPlaceholderCols)
		{
			if (!string.IsNullOrWhiteSpace(phCol.Description))
            {
#>
        /// <summary>
        /// <#= phCol.Description #>
        /// </summary>
<#
            }
			if (AddApiAttributes)
            {
				List<string> lstApiMemberProps = GetApiMemberProps(phCol, allEnums, lstInterfaces);
				if (lstApiMemberProps.Any())
				{
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>)]
<#
				}
            }
#>
        public <#= phCol.ProperPropertyType #> <#= phCol.PropertyName #> { get; set; }

<#
		}
#>
        /// <summary>
        /// <#= fieldsPropDescription #>
        /// </summary>
<#
			    if (AddApiAttributes)
                {
#>
        [ApiMember(Description = "<#= fieldsPropDescription #>", DataType = SwaggerDataTypes.ArrayOfString)]
<#
                }
#>
        public string[] Fields { get; set; }
	}
}
<#
			manager.EndBlock(); // end newfile
		}

		/**********************/
		/** BEGIN DELETEBYID **/
		/**********************/

		bool deleteExcluded = DeleteTableFilterExclude != null && DeleteTableFilterExclude.IsMatch(table.ClassName);
		if (!deleteExcluded)
		{
			string deleteTableClassName = "Delete" + table.ClassName;
			string deleteTableClassDescription = "Supprime une ressource {0}.";

			manager.StartNewFile(deleteTableClassName + ".generated.cs");
#>
using System.Net;
using ServiceStack;
<#
			if (pocoNamespace != msgNamespace)
            {
#>
using <#= pocoNamespace #>;
<#
			}
#>

namespace <#= msgNamespace #>
{
	/// <summary>
	/// <#= string.Format(deleteTableClassDescription, "<see cref=\"" + table.ClassName + "\" />") #>
	/// </summary>
<#
            if (AddRouteAttributes)
            {
				string strRouteBase = "/" + string.Join("/", lstRouteBaseParts);
				string strRouteKey = "/" + string.Join("/", lstRouteKeyParts);
#>
	[Route("<#= strRouteBase #><#= strRouteKey #>", HttpVerbs.Delete, Summary = "<#= string.Format(deleteTableClassDescription, "'" + resourceName + "'") #>")]
<#
			    if (AddApiAttributes)
                {
#>
    [ApiResponse(HttpStatusCode.NotFound, "La ressource '<#= resourceName #>' spécifiée est introuvable.")]
<#
                }
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= deleteTableClassName #> : IReturnVoid
	{
<#
		foreach (Column phCol in lstPlaceholderCols)
		{
			if (!string.IsNullOrWhiteSpace(phCol.Description))
            {
#>
        /// <summary>
        /// <#= phCol.Description #>
        /// </summary>
<#
            }
			if (AddApiAttributes)
            {
				List<string> lstApiMemberProps = GetApiMemberProps(phCol, allEnums, lstInterfaces);
				if (lstApiMemberProps.Any())
				{
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>)]
<#
				}
            }
#>
        public <#= phCol.ProperPropertyType #> <#= phCol.PropertyName #> { get; set; }

<#
		}
#>
	}
}
<#
			manager.EndBlock(); // end newfile
		}

		/*********************/
		/** BEGIN PATCHBYID **/
		/*********************/

		bool patchExcluded = PatchTableFilterExclude != null && PatchTableFilterExclude.IsMatch(table.ClassName);
		if (!patchExcluded)
		{
			string patchTableClassName = "Patch" + table.ClassName;
			string patchTableClassDescription = "Modifie partiellement une ressource {0}.";
			string fieldsPropDescription = "Liste des modifications.";

			manager.StartNewFile(patchTableClassName + ".generated.cs");
#>
using System.Net;
using ServiceStack;
<#
			if (pocoNamespace != msgNamespace)
            {
#>
using <#= pocoNamespace #>;
<#
			}
#>

namespace <#= msgNamespace #>
{
	/// <summary>
	/// <#= string.Format(patchTableClassDescription, "<see cref=\"" + table.ClassName + "\" />") #>
	/// </summary>
<#
            if (AddRouteAttributes)
            {
				string strRouteBase = "/" + string.Join("/", lstRouteBaseParts);
				string strRouteKey = "/" + string.Join("/", lstRouteKeyParts);
#>
	[Route("<#= strRouteBase #><#= strRouteKey #>", HttpVerbs.Patch, Summary = "<#= string.Format(patchTableClassDescription, "'" + resourceName + "'") #>")]
<#
			    if (AddApiAttributes)
                {
#>
    [ApiResponse(HttpStatusCode.BadRequest, "La ressource '<#= resourceName #>' ne contient pas tous les champs demandés.")]
    [ApiResponse(HttpStatusCode.NotFound, "La ressource '<#= resourceName #>' spécifiée est introuvable.")]
<#
                }
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= patchTableClassName #> : IReturnVoid
	{
<#
		foreach (Column phCol in lstPlaceholderCols)
		{
			if (!string.IsNullOrWhiteSpace(phCol.Description))
            {
#>
        /// <summary>
        /// <#= phCol.Description #>
        /// </summary>
<#
            }
			if (AddApiAttributes)
            {
				List<string> lstApiMemberProps = GetApiMemberProps(phCol, allEnums, lstInterfaces);
				if (lstApiMemberProps.Any())
				{
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>)]
<#
				}
            }
#>
        public <#= phCol.ProperPropertyType #> <#= phCol.PropertyName #> { get; set; }

<#
		}
#>
        /// <summary>
        /// <#= fieldsPropDescription #>
        /// </summary>
<#
			    if (AddApiAttributes)
                {
#>
        [ApiMember(Description = "<#= fieldsPropDescription #>", DataType = "Array[" + nameof(Patch) + "]", IsRequired = true, ParameterType = SwaggerParamTypes.Form)]
<#
                }
#>
        public Patch[] Fields { get; set; }
	}
}
<#
			manager.EndBlock(); // end newfile
		}

		string stdColFormat = GetStandardColumnFormat(table);
		bool hasCodObjet = table.Columns.Any(c => c.PropertyType == "string" && c.PropertyName == string.Format(stdColFormat, "Cod"));
		bool hasLibObjet = table.Columns.Any(c => c.PropertyType == "string" && c.PropertyName == string.Format(stdColFormat, "Lib"));
		bool hasEstActif = table.Columns.Any(c => c.PropertyType == "bool" && c.PropertyName == "EstActif");

		if (hasCodObjet && hasLibObjet && hasEstActif)
        {
			/************************/
			/** BEGIN AUTOCOMPLETE **/
			/************************/

			bool autocompleteExcluded = AutocompleteTableFilterExclude != null && AutocompleteTableFilterExclude.IsMatch(table.ClassName);
			if (!autocompleteExcluded)
			{
				var autocompleteClassName = "Autocomplete" + table.ClassName;
				var autocompleteDescription = "Retourne des prédictions sur les ressources '{0}'.";
				var textPropDescription = "Texte à rechercher.";
				var maxPropDescription = "Nombre maximum de prédictions à retourner.";

				manager.StartNewFile(autocompleteClassName + ".generated.cs");
#>
using System.Net;
using ServiceStack;
<#
			if (pocoNamespace != msgNamespace)
            {
#>
using <#= pocoNamespace #>;
<#
			}
#>

namespace <#= msgNamespace #>
{
	/// <summary>
	/// <#= string.Format(autocompleteDescription, "<see cref=\"" + table.ClassName + "\" />") #>
	/// </summary>
<#
			if (AddRouteAttributes)
            {
				string strRouteBase = "/" + string.Join("/", lstRouteBaseParts);
#>
	[Route("<#= strRouteBase #>/Autocomplete/{Text}", HttpVerbs.Get, Summary = "<#= string.Format(autocompleteDescription, table.ClassName) #>")]
<#
			}
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= autocompleteClassName #> : IReturn<BasicEntity[]>
	{
        /// <summary>
        /// <#= textPropDescription #>
        /// </summary>
<#
			    if (AddApiAttributes)
                {
#>
        [ApiMember(Description = "<#= textPropDescription #>", DataType = SwaggerDataTypes.String, IsRequired = true, ParameterType = SwaggerParamTypes.Path)]
<#
                }
#>
        public string Text { get; set; }

        /// <summary>
        /// <#= maxPropDescription #>
        /// </summary>
<#
			    if (AddApiAttributes)
                {
#>
        [ApiMember(Description = "<#= maxPropDescription #>", DataType = SwaggerDataTypes.Int)]
<#
                }
#>
        public int Max { get; set; }
	}
}
<#
				manager.EndBlock(); // end newfile
            }
        }
    } // end foreach (table)
	
    manager.Process(SplitIntoMultipleFiles);
#>
<#+
/// <summary>
/// Retourne une chaine qui représente le format que doit avoir une colonne standard (CodObjet, LibObjet, TxtObjet...) dans une table.
/// Exemple : GenService => "{0}Service" ; GenPersonneProfil => "{0}Profil" ...
/// </summary>
private string GetStandardColumnFormat(Table table)
{
	FKey parentFkey = GetParentFKey(table);
	if (parentFkey != null)
	{
		return parentFkey.FromTable.ClassName.Replace(parentFkey.ReferencedTable.ClassName, "{0}");
	}
	return "{0}" + table.Name.Remove(0, 3);
}

/// <summary>
/// Retourne une chaine qui représente le format que doit avoir une colonne FK dans une table.
/// Exemple : CleService => "{0}" ; CleTiersPayeur => "{0}Payeur" ...
/// </summary>
private string GetFKeyColumnFormat(FKey fkey)
{
	Column fkFromCol = fkey.FromColumns.Single();
	Column fkRefCol = fkey.ReferencedColumns.Single();

	return fkFromCol.PropertyName.Replace(fkRefCol.PropertyName, "{0}");
}

private void SetColumnsDescription(Table table, string stdColFormat)
{
	foreach (Column col in table.Columns)
    {
		if (string.IsNullOrWhiteSpace(col.Description))
        {
			if (col.IsPKey)
			{
				col.Description = "Clé primaire.";
			}
			else if (col.PropertyName == string.Format(stdColFormat, "Cod"))
			{
				bool isUniqueSingleCol = table.Indices
					.Where(idx => idx.IsUnique == true && idx.IndexColumns.Count == 1 && idx.IndexColumns.Contains(col))
					.Any();
				col.Description = isUniqueSingleCol ? "Code unique." : "Code.";
			}
			else if (col.PropertyName == string.Format(stdColFormat, "Lib"))
			{
				col.Description = "Désignation.";
			}
			else if (col.PropertyName == string.Format(stdColFormat, "Txt"))
			{
				col.Description = "Commentaire ou description.";
			}
			else
			{
				switch (col.PropertyName)
				{
					case "EstActif":
						col.Description = "Actif ou inactif.";
						break;
					case "DatCreation":
						col.Description = "Date de création.";
						break;
					case "DatModif":
						col.Description = "Date de dernière modification.";
						break;
					case "CodExterne":
						col.Description = "Identifiant de synchronisation externe.";
						break;

					case "NumTelep":
						col.Description = "Numéro de téléphone.";
						break;
					case "NumFax":
						col.Description = "Numéro de fax.";
						break;
					case "NumEmail":
						col.Description = "Adresse email.";
						break;

					case "AdrRue":
						col.Description = "Rue.";
						break;
					case "AdrCode":
						col.Description = "Code postal.";
						break;
					case "AdrCommune":
						col.Description = "Ville ou commune.";
						break;
					case "AdrPays":
						col.Description = "Pays.";
						break;
				}
			}
        }
		else if (!col.Description.EndsWith("."))
		{
			col.Description += ".";
		}
    }
}

List<string> GetApiMemberProps(Column col, List<string> lstEnums, List<string> lstInterfaces)
{
    List<string> lstApiMemberProps = new List<string>();

    if (!string.IsNullOrEmpty(col.Description))
    {
        lstApiMemberProps.Add("Description = \"" + col.Description + "\"");
    }
                
    string swagDataType = "";

    if (lstEnums.Contains(col.PropertyType))
    {
        //swagDataType = "SwaggerDataTypes.String";
    }
    else if (col.PropertyType == "byte[]")
    {
        swagDataType = "SwaggerDataTypes.File";
    }
    else
    {
        swagDataType = "SwaggerDataTypes." + col.PropertyType.Substring(0,1).ToUpper() + col.PropertyType.Substring(1);
    }

    if (!string.IsNullOrEmpty(swagDataType))
    {
        lstApiMemberProps.Add("DataType = " + swagDataType);
    }

    if (!col.IsPKey)
    {
        if (col.IsNullable == false && col.IsAutoIncrement == false)
        {
            bool required = true;
            if (lstInterfaces.Contains("IAuditable") && (col.ProperPropertyType == "DateTime")
                && (col.PropertyName == "DatCreation" || col.PropertyName == "DatModif"))
            {
                required = false;
            }
            if (required)
            {
                lstApiMemberProps.Add("IsRequired = true");
            }
        }
    }

	return lstApiMemberProps;
}

/// <summary>
/// Cherche parmi les PK ou les contraintes uniques les meilleures colonnes pour identifier la ressource.
/// </summary>
List<Column> GetBestUniqueColumns(Table table, bool usePK)
{
	List<Column> pkCols = null;

	if (table.PrimaryKey != null)
    {
		pkCols = table.PrimaryKey.PKeyColumns;
    }

	if (usePK)
    {
		return pkCols;
    }
	else 
    {
		TableIndex index = table.Indices.Where(idx => idx.IsUnique)
			.OrderBy(idx => idx.IndexColumns.Count)
			.FirstOrDefault();
		if (index != null)
		{
			return index.IndexColumns;
		}
    }

    return pkCols;
}

/// <summary>
/// Retourne la FK pointant sur la table parent la plus proche.
/// </summary>
FKey GetParentFKey(Table table)
{
    // si plusieurs parents, on prend celui avec le nom le plus long
    FKey fkey = table.ForeignKeys
		.Where(fk => table.Name.StartsWith(fk.ReferencedTable.Name))
		.OrderByDescending(fk => fk.ReferencedTable.Name.Length)
		.FirstOrDefault();
	return fkey;
}

/// <summary>
/// Extraction du route path suivant les ForeignKeys/enfants
/// Exemple : classe GenFournContact passe de '/GenFournContact/' en '/GenFourn/{xxx}/Contact/'
/// </summary>
List<string> GetRoutePartsFromTable(Table table, bool usePK, ref List<Column> lstPlaceholderCols)
{
    List<string> lstRoute = new List<string>();
    List<string> parts = new List<string>();

	FKey fkParent = GetParentFKey(table);
    if (fkParent != null)
    {
		Table parentTable = fkParent.ReferencedTable;
	    List<Column> parentCols = GetBestUniqueColumns(parentTable, usePK);
        if (parentCols != null)
        {
			string format = GetFKeyColumnFormat(fkParent);

			foreach (Column col in parentCols)
            {
				Column newCol = col.Clone();
				newCol.PropertyName = string.Format(format, newCol.PropertyName);

				lstPlaceholderCols.Add(newCol);
				parts.Add("{" + newCol.PropertyName + "}");
            }
        }

        string newTableName = table.Name.Replace(parentTable.Name, "");
        parts.Add(newTableName);

        lstRoute = GetRoutePartsFromTable(parentTable, usePK, ref lstPlaceholderCols);
    }
    if (!parts.Any())
    {
		string newTableName = table.Name.Remove(0, 3);
        parts.Add(newTableName);
    }

    lstRoute.AddRange(parts);
    return lstRoute;
}
#>