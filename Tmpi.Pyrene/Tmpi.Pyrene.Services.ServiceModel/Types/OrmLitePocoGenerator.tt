<#@ template language="C#" hostspecific="true" #>
<#@ include file="$(SolutionDir)Shared\MultipleOutputHelper.ttinclude" #>
<#@ include file="$(SolutionDir)Shared\VisualStudioHelper.ttinclude" #>
<#@ include file="$(SolutionDir)Shared\OrmLite.Core.ttinclude" #>
<#
	/***** TODO *****
	- DefaultAttribute
    - Alternative a TransformRoutePath avec des const
    - Commentaires sur les [References] ?
    - Ajout de propriétés [References] pour les FK ?
	****************/

	/*********************/
	/** CUSTOM SETTINGS **/
	/*********************/

	ConnectionStringName = "PyreneModel";			// Uses last connection string in config if not specified
	ClassPrefix = "";
	ClassSuffix = "";

	// Namespace des fichiers générés. Si vide DefaultNamespace du projet/répertoire courant.
	string Namespace = "";

	// true pour générer des classes partial.
	bool MakeClassesPartial = true;

    // true pour générer des propriétés virtual.
    bool MakePropertiesVirtual = false;

	// true pour générer chaque classe dans un fichier séparé.
	bool SplitIntoMultipleFiles = true;

	// if true: Changes the primary key property name to Id.
	bool UseIdAsPK = false;

	// if true: Generates the default empty constructor.
	bool GenerateEmptyConstructor = false;

	// if true: Adds explicit '[Schema]' attribute.
	bool UseSchemaAttribute = true;

	// if true: Adds References(typeof(ReferenceTableType)) to FKs.
	bool IncludeReferences = true;

	// true: Ajoute [Index] et [CompositeIndex].
	bool IncludeIndices = true;

	// Ajoute les interfaces IAuditable, etc...
	bool AddCustomInterfaces = true;

	// Ajoute des propriétés avec l'attribut [Reference] pour les tables enfants
	bool AddChildReferences = true;

	// Ajoute [ApiMember], [ApiAllowableValues]...
	bool AddApiAttributes = true;

	// true pour ajouter l'attribut [Route(...)] sur les classes générées.
	bool AddRouteAttributes = true;

	// true pour transformer la route de la ressource, ex: GenFournContact de '/GenFournContact/' en '/GenFourn/Contact/'.
	bool TransformRoutePath = true;

	// Filtre les routes générées.
	Regex PutTableFilterExclude = null;
	Regex PostTableFilterExclude = null;

	// if true: Changes the classname to singular if tablename is not singular.
	bool MakeSingular = false;

	// if true: Will create <TypeName>Query types with all possible search fields explicitly typed.
	bool CreateAutoQueryTypes = false;

	// if true: Adds NamedConnection attribute so AutoQuery will override default IDbConnection
	bool AddNamedConnection = false;

	// if not null: Will use name provided as NamedConnection and AddNamedConnection = true, else ConnectionStringName is used as default NamedConnection
	string UseSpecificNamedConnection = "";

	// Si non null, méthode appliquée sur la collection des tables
	Action<Tables> tweakSchema = null;
	tweakSchema = tables =>
    {	
		// Tweak Schema
		// tables["tablename"].Ignore = true;							// To ignore a table
		// tables["tablename"].ClassName = "newname";					// To change the class name of a table
		// tables["tablename"]["columnname"].Ignore = true;			// To ignore a column
		// tables["tablename"]["columnname"].PropertyName="newname";	// To change the property name of a column
		// tables["tablename"]["columnname"].PropertyType="bool";		// To change the property type of a column

		try
		{
			tables["__RefactorLog"].Ignore = true;
		}
		catch {
		}
		
		try
		{
			// enums
			tables["GenCompteur"]["TypCompteur"].PropertyType = "TypCompteur";
			tables["GenCompteur"]["TypPeriodicite"].PropertyType = "TypPeriodicite";
			tables["GenMandat"]["TypMandat"].PropertyType = "TypMandat";
			tables["GenPersonne"]["TypCivilite"].PropertyType = "TypCivilite";
			tables["GenFourn"]["TypModeReglement"].PropertyType = "TypModeReglement";
			tables["GenFournContact"]["TypCivilite"].PropertyType = "TypCivilite";
		}
		catch {
		}
    };

#>
<#
    // Read schema
	var allTables = LoadTables(MakeSingular);

	if (tweakSchema != null)
    {
		tweakSchema(allTables);
    }

	// transformation du route path suivant les ForeignKeys
	// exemple : classe GenFournContact passe de '/GenFournContact/' en '/GenFourn/Contact/'
	Func<Table, List<string>> getRoutePathFromTable = null;
	getRoutePathFromTable = table =>
	{
		var lstRoute = new List<string>();
		string str = null;

		if (table.FKeys != null && table.FKeys.Any())
		{
			var refTableNames = table.FKeys
				.Where(fk => table.Name.StartsWith(fk.ToTable))
				.Select(fk => fk.ToTable)
				.ToList();

			string refTableName = refTableNames.OrderByDescending(s => s.Length).FirstOrDefault();
			if (!string.IsNullOrEmpty(refTableName))
			{
				var tbl = allTables.SingleOrDefault(c => c.Name == refTableName) as Table;
				if (tbl != null)
				{
					str = table.Name.Replace(tbl.Name, "");
					lstRoute = getRoutePathFromTable(tbl);
				}
			}
		}
		if (string.IsNullOrEmpty(str))
		{
			str = table.Name;
		}

		lstRoute.Add(str);
		return lstRoute;
	};

	// namespace
	var fileNamespace = Namespace;
	if (string.IsNullOrWhiteSpace(fileNamespace))
	{
		fileNamespace = VisualStudioHelper.CurrentFileNamespace;
	}

	var manager = Manager.Create(Host, GenerationEnvironment);
	manager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable 1591

using System;
using System.Collections.Generic;
using System.Net;
using ServiceStack;
using ServiceStack.DataAnnotations;
using ServiceStack.Model;

namespace <#= fileNamespace #>
{
<#
	manager.EndBlock(); // end header
    
	// get a reference to the project of this t4 template
	var project = VisualStudioHelper.CurrentProject;

    var allEnums = VisualStudioHelper.CodeModel.GetAllCodeElementsOfType(project.CodeModel.CodeElements, EnvDTE.vsCMElement.vsCMElementEnum, false)
        .OfType<EnvDTE.CodeEnum>().Select(x => x.Name);

	foreach (Table table in allTables)
	{
		if (table.Ignore)
		{
			continue;
		}

		manager.StartNewFile(table.ClassName + ".generated.cs");

		if (CreateAutoQueryTypes && AddNamedConnection)
		{
#>
	[NamedConnection("<#= !string.IsNullOrEmpty(UseSpecificNamedConnection) ? UseSpecificNamedConnection : ConnectionStringName #>")]
<#
		} // end if

		if (table.ClassName != table.Name)
		{
#>
	[Alias("<#= table.Name #>")]
<#
		} // end if
		
		if (UseSchemaAttribute && !string.IsNullOrEmpty(table.Schema) && table.Schema != "dbo")
		{
#>
	[Schema("<#= table.Schema #>")]
<#
		} // end if
		
		if (IncludeIndices && table.Indices != null)
		{
			foreach (var idx in table.Indices.Where(i => i.IndexColumns.Count > 1))
			{
                var q = from c1 in idx.IndexColumns
                        join c2 in table.Columns on c1.Name equals c2.Name
                        let noAlias = (c2.Name == c2.PropertyName)
                        select noAlias ? "nameof(" + c2.PropertyName + ")" : "\"" + c2.Name + "\"";
                var idxColumns  = q.ToList();
#>
	[CompositeIndex(<#= idx.IsUnique ? "true, " : "" #><#= string.Join(", ", idxColumns) #>)]
<#
			} // end foreach
		} // end if

		bool putExcluded = PutTableFilterExclude != null && PutTableFilterExclude.IsMatch(table.ClassName);
		bool postExcluded = PostTableFilterExclude != null && PostTableFilterExclude.IsMatch(table.ClassName);

        if (AddRouteAttributes && (!putExcluded || !postExcluded))
        {
    		string strRoute = table.ClassName;
		    if (TransformRoutePath)
		    {
			    strRoute = string.Join("/", getRoutePathFromTable(table));
		    }
            if (!postExcluded)
            {
#>
    [Route("/<#= strRoute #>", HttpVerbs.Post, Summary = "<#= string.Format("Ajoute une ressource {0}.", table.ClassName) #>")]
<#
            }
            if (!putExcluded)
            {
#>
    [Route("/<#= strRoute #>/{Id}", HttpVerbs.Put, Summary = "<#= string.Format("Remplace une ressource {0} à partir de son Id.", table.ClassName) #>")]
<#
            }

            if (AddApiAttributes)
            {
#>
    [ApiResponse(HttpStatusCode.NotFound, "La ressource <#= table.ClassName #> spécifiée est introuvable.")]
<#
            }
        } // end if
		
		var lstInterfaces = new List<string>();

		if (table.HasPK())
		{
            if (UseIdAsPK)
            {
                table.PK.PropertyName = "Id";
            }
		    if (table.PK.PropertyName == "Id")
		    {
			    lstInterfaces.Add("IHasId<" + table.PK.PropertyType + ">");
		    }
		}
		if (AddCustomInterfaces)
        {
			if (table.Columns.Any(c => c.PropertyName == "CodObjet" && c.ProperPropertyType == "string") &&
				table.Columns.Any(c => c.PropertyName == "LibObjet" && c.ProperPropertyType == "string") &&
				table.Columns.Any(c => c.PropertyName == "EstActif" && c.ProperPropertyType == "bool"))
            {
				lstInterfaces.Add("IEntity");
            }
			if (table.Columns.Any(c => c.PropertyName == "DatCreation" && c.ProperPropertyType == "DateTime") &&
				table.Columns.Any(c => c.PropertyName == "DatModif" && c.ProperPropertyType == "DateTime"))
            {
				lstInterfaces.Add("IAuditable");
            }
        }

		var classDefinitionWords = new List<string>();
		classDefinitionWords.Add("public");
		if (MakeClassesPartial)
        {
			classDefinitionWords.Add("partial");
        }
#>
	<#= string.Join(" ", classDefinitionWords) #> class <#= table.ClassName #><#= lstInterfaces.Any() ? " : " + string.Join(",\r\n\t\t", lstInterfaces) : "" #>
	{
<#
		if (GenerateEmptyConstructor)
		{
#>
        /// <summary>
        /// Initialise une nouvelle instance de la classe <see cref="<#= table.ClassName #>" />.
        /// </summary>
		public <#= table.ClassName #>()
		{
		}

<#
		} // end if

		var priorProperyNames = new List<string>();
		foreach (Column col in table.Columns)
		{
			if (col.Ignore)
			{
				continue;
			}

			if (priorProperyNames.Contains(col.PropertyName)) //Change duplicate style names
			{
				col.PropertyName = "_" + col.PropertyName;
			}
			priorProperyNames.Add(col.PropertyName);

			if (string.IsNullOrWhiteSpace(col.Description))
            {
				if (col.IsPK)
                {
					col.Description = "Clé primaire.";
                }
				else
                {
					switch (col.PropertyName)
                    {
						case "CodObjet":
                            bool isUnique = false;
                            if (table.Indices != null)
                            {
				                var q = from idx in table.Indices
                                        where idx.IsUnique == true
						                where idx.IndexColumns.Count == 1
                                        where idx.IndexColumns.Any(c => c.Name == col.Name)
						                select idx;
                                isUnique = q.Any();
                            }
							col.Description = isUnique ? "Code unique." : "Code.";
							break;
						case "LibObjet":
							col.Description = "Désignation.";
							break;
						case "TxtObjet":
							col.Description = "Commentaire ou description.";
							break;
						case "EstActif":
							col.Description = "Actif ou inactif";
							break;
						case "DatCreation":
							col.Description = "Date de création.";
							break;
						case "DatModif":
							col.Description = "Date de dernière modification.";
							break;
						case "CodExterne":
							col.Description = "Identifiant de synchronisation externe.";
							break;

						case "NumTelep":
							col.Description = "Numéro de téléphone.";
							break;
						case "NumFax":
							col.Description = "Numéro de fax.";
							break;
						case "NumEmail":
							col.Description = "Adresse email.";
							break;

						case "AdrRue":
							col.Description = "Rue.";
							break;
						case "AdrCode":
							col.Description = "Code postal.";
							break;
						case "AdrCommune":
							col.Description = "Ville ou commune.";
							break;
						case "AdrPays":
							col.Description = "Pays.";
							break;
                    }
                }
            }

			if (!string.IsNullOrWhiteSpace(col.Description))
            {
                if (!col.Description.EndsWith("."))
			    {
				    col.Description += ".";
			    }
#>
		/// <summary>
		/// <#= col.Description #>
		/// </summary>
<#
            }

			if (col.Name != col.PropertyName)
			{
#>
        [Alias("<#= col.Name #>")]
<#
			} // end if

			if (col.PropertyType == "string" && col.Size > 0)
			{
#>
		[StringLength(<#= col.Size #>)]
<#
			} // end if
			
			if (col.PropertyType == "decimal" && col.Precision > 0)
            {
#>
		[DecimalLength(<#= col.Precision #>, <#= col.Scale #>)]
<#
            } // end if

			if (col.IsAutoIncrement)
			{
#>
		[AutoIncrement]
<#
			} // end if

			if (col.IsComputed)
			{
#>
		[Compute]        
<#
			} // end if

			if (IncludeReferences && table.FKeys != null)
			{
				var fKey = table.FKeys.FirstOrDefault(x => x.FromColumn == col.Name);
				if (fKey != null)
                {
					var tbl = allTables.SingleOrDefault(t => t.Name == fKey.ToTable);
					if (tbl != null)
                    {
						if (fKey.IsDeleteCascade)
						{
#>
		[ForeignKey(typeof(<#= tbl.ClassName #>), OnDelete = "CASCADE")]
<#
						} // end if
						else
						{
#>
		[References(typeof(<#= tbl.ClassName #>))]
<#
						} // end else
                    } // end if
                } // end if
			} // end if

			if (col.IsNullable == false && col.IsAutoIncrement == false)
			{
#>
		[Required]
<#
			} // end if

			if (IncludeIndices && table.Indices != null)
			{
				var q = from idx in table.Indices
						where idx.IndexColumns.Count == 1
                        where idx.IndexColumns.Any(c => c.Name == col.Name)
						select idx;
				if (q.Any())
				{
					var indx = q.First();
#>
		[Index<#= indx.IsUnique ? "(true)" : "" #>]
<#
				} // end if
			} // end if

			if (col.IsPK && (col.PropertyName != "Id"))
			{
#>
		[PrimaryKey]
<#
			} // end if

			if (AddApiAttributes)
			{
				var lstApiMemberProps = new List<string>();

				if (!string.IsNullOrEmpty(col.Description))
                {
					lstApiMemberProps.Add("Description = \"" + col.Description + "\"");
                }
                
                string swagDataType = "";

                if (allEnums.Contains(col.PropertyType))
                {
                    //swagDataType = "SwaggerDataTypes.String";
                }
                else if (col.PropertyType == "byte[]")
                {
                    swagDataType = "SwaggerDataTypes.File";
                }
                else
                {
                    swagDataType = "SwaggerDataTypes." + col.PropertyType.Substring(0,1).ToUpper() + col.PropertyType.Substring(1);
                }

                if (!string.IsNullOrEmpty(swagDataType))
                {
                    lstApiMemberProps.Add("DataType = " + swagDataType);
                }

                if (col.IsPK && (!putExcluded || !postExcluded))
                {
                    if (!postExcluded)
                    {
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>, Verb = HttpVerbs.Post)]
<#
                    }
                    if (!putExcluded)
                    {
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>, Verb = HttpVerbs.Put, IsRequired = true, ParameterType = SwaggerParameterTypes.Path)]
<#
                    }
                }
                else
                {
                    if (col.IsNullable == false && col.IsAutoIncrement == false)
                    {
                        bool required = true;
                        if (lstInterfaces.Contains("IAuditable") && (col.ProperPropertyType == "DateTime")
                            && (col.PropertyName == "DatCreation" || col.PropertyName == "DatModif"))
                        {
                            required = false;
                        }
                        if (required)
                        {
                            lstApiMemberProps.Add("IsRequired = true");
                        }
                    }

                    if (lstApiMemberProps.Any())
                    {
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>)]
<#
			        } // end if
                } // end if

                if (allEnums.Contains(col.PropertyType))
                {
#>
		[ApiAllowableValues(nameof(<#= col.PropertyName #>), typeof(<#= col.PropertyType #>))]
<#
                }

			} // end if
#>
		public <#= MakePropertiesVirtual ? "virtual " : "" #><#= col.ProperPropertyType #> <#= col.PropertyName #> { get; set; }

<#
		} // end foreach

		if (AddChildReferences)
        {
			var q = from tbl in allTables
					where tbl.FKeys != null
					where tbl.Name.StartsWith(table.Name)
					from fk in tbl.FKeys
					where fk.ToTable == table.Name
					let fkIsPK = tbl.HasPK() && tbl.PK.Name == fk.FromColumn
					let fkIsUnique = tbl.Indices != null &&
						tbl.Indices.Any(idx => idx.IsUnique && idx.IndexColumns.Count == 1 && idx.IndexColumns[0].Name == fk.FromColumn)
					select new
					{
						Table = tbl,
						IsUnique = fkIsPK || fkIsUnique
					};
			foreach (var obj in q)
            {
				string propType = obj.Table.ClassName;
				string propName = obj.Table.ClassName.Replace(table.ClassName, "");
				if (!obj.IsUnique)
                {
						propType = "List<" + propType + ">";
                        propName = "Lst" + propName;
                }
#>
		[Reference]
		public <#= MakePropertiesVirtual ? "virtual " : "" #><#= propType #> <#= propName #> { get; set; }

<#
            }
        }
#>
	}
<#
		manager.EndBlock(); // end newfile

		if (CreateAutoQueryTypes)
		{
			manager.StartNewFile(table.ClassName + "Query.generated.cs");
			
			var queryClassDefinitionWords = new List<string>();
			queryClassDefinitionWords.Add("public");
			if (MakeClassesPartial)
			{
				queryClassDefinitionWords.Add("partial");
			}
#>
	<#= string.Join(" ", queryClassDefinitionWords) #> class <#= table.ClassName #>Query : QueryDb<<#= table.ClassName #>>
	{
<#
		foreach (Column col in table.Columns)
		{
			if (col.Ignore)
			{
				continue;
			}

			var ormName = (col.IsPK && UseIdAsPK) ? "Id" : col.PropertyName;
			var isString = col.ProperPropertyType == "string";
			var nullablePropType = col.ProperPropertyType.Replace("?", "") + "?";
			var isArray = col.ProperPropertyType.Contains("[]");
			var isBool = col.ProperPropertyType.Contains("bool");
			var isGuid = col.ProperPropertyType.Contains("Guid");
			
			if (!col.IsPK)
			{
#>
		public <#= !isArray && !isString ? nullablePropType : col.ProperPropertyType #> <#= ormName #> { get; set; }
<#
			}
			if (col.IsPK && UseIdAsPK)
			{
#>
		public <#= isString ? "string" : nullablePropType #> Id { get; set; }
<#
			}
			if (col.IsPK && !UseIdAsPK)
			{
#>
		public <#= isString ? "string" : nullablePropType#> <#= col.PropertyName #> { get; set; }
<#
			}
			if (isString)
			{
#>
		public <#= col.ProperPropertyType #> <#= ormName #>StartsWith { get; set; }
		public <#= col.ProperPropertyType #> <#= ormName #>EndsWith { get; set; }
		public <#= col.ProperPropertyType #> <#= ormName #>Contains { get; set; }
		public <#= col.ProperPropertyType #> <#= ormName #>Like { get; set; } 
		public <#= col.ProperPropertyType #>[] <#= ormName #>Between { get; set; }
		public <#= col.ProperPropertyType #>[] <#= ormName #>In { get; set; }
<#
			}
			else if (!isArray && !isBool)
			{
				if (!isGuid)
				{
#>
		public <#= nullablePropType #> <#= ormName #>GreaterThanOrEqualTo { get; set; }
		public <#= nullablePropType #> <#= ormName #>GreaterThan { get; set; }
		public <#= nullablePropType #> <#= ormName #>LessThan { get; set; }
		public <#= nullablePropType #> <#= ormName #>LessThanOrEqualTo { get; set; }
		public <#= nullablePropType #> <#= ormName #>NotEqualTo { get; set; }
		public <#= col.ProperPropertyType #>[] <#= ormName #>Between { get; set; }
<#
				}
#>
		public <#= col.ProperPropertyType #>[] <#= ormName #>In { get; set; }
<#
			} // end elseif
#>

<#
		} // end foreach
#>
	}
<#
		}

		manager.EndBlock(); // end newfile
	} // end foreach
	
	manager.StartFooter();
#>
}
<#
	manager.EndBlock(); // end footer
	
	manager.Process(SplitIntoMultipleFiles);
#>
