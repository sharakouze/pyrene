<#@ template language="C#" hostspecific="true" debug="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="EnvDTE.dll" #>
<#@ assembly name="System.Core.dll" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Linq" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\MultipleOutputHelper.ttinclude" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\VisualStudioHelper.ttinclude" #>
<#@ include file="$(MSBuildProjectDirectory)\..\Shared\SqlSchemaReader.ttinclude" #>
<#
	/***** TODO *****
	- DefaultAttribute
    - Alternative a TransformRoutePath avec des const
    - Commentaires sur les [References] ?
    - Ajout de propriétés [References] pour les FK ?
	****************/

	/*********************/
	/** CUSTOM SETTINGS **/
	/*********************/

	// chaine de connection pour l'extration du schéma
    string ConnectionString = @"Server=(LocalDB)\MSSQLLocalDB;Database=TMPI_PYRENE;Integrated Security=True;MultipleActiveResultSets=True";

	// schema ou vide pour tous les schémas
	string SchemaName = "";

    // if true: Changes the classname to singular if tablename is not singular.
    bool MakeSingular = false;

    // Namespace des fichiers générés. Si vide DefaultNamespace du projet/répertoire courant.
    string Namespace = "";

    // true pour générer des classes partial.
    bool MakeClassesPartial = true;

    // true pour générer des propriétés virtual.
    bool MakePropertiesVirtual = false;

    // true pour générer chaque classe dans un fichier séparé.
    bool SplitIntoMultipleFiles = true;

    // if true: Changes the primary key property name to Id.
    bool UseIdAsPK = false;

    // if true: Generates the default empty constructor.
    bool GenerateEmptyConstructor = false;

    // if true: Adds explicit '[Schema]' attribute.
    bool UseSchemaAttribute = true;

    // if true: Adds References(typeof(ReferenceTableType)) to FKs.
    bool IncludeReferences = true;

    // true: Ajoute [Index] et [CompositeIndex].
    bool IncludeIndices = true;

    // Ajoute les interfaces IAuditable, etc...
    bool AddCustomInterfaces = true;

    // Ajoute des propriétés avec l'attribut [Reference] pour les tables enfants
    bool AddChildReferences = true;

    // Ajoute [ApiMember], [ApiAllowableValues]...
    bool AddApiAttributes = true;

    // true pour ajouter l'attribut [Route(...)] sur les classes générées.
    bool AddRouteAttributes = true;

    // true pour transformer la route de la ressource, ex: GenFournContact de '/GenFournContact/' en '/GenFourn/{xxx}/Contact/'.
    bool TransformRoutePath = true;

	// false pour preferer l'utilisation des contraintes d'unicité plutot que les PK pour identifier les ressources.
    bool UsePKAsRouteId = false;

    // Filtre les routes générées.
    Regex PutTableFilterExclude = null;
    Regex PostTableFilterExclude = null;

    // Si non null, méthode appliquée sur la collection des tables
    Action<Tables> TweakSchema = (tables) =>
    {	
		tables.ForEach(t => SetDescription(t));

		tables.RemoveAll(t => t.Name == "__RefactorLog");

		tables.ChangePropertyType("GenCompteur", "TypCompteur", "TypCompteur");
		tables.ChangePropertyType("GenCompteur", "TypPeriodicite", "TypPeriodicite");
		tables.ChangePropertyType("GenMandat", "TypMandat", "TypMandat");
		tables.ChangePropertyType("GenPersonne", "TypCivilite", "TypCivilite");
		tables.ChangePropertyType("GenFourn", "TypModeReglement", "TypModeReglement");
		tables.ChangePropertyType("GenFournContact", "TypCivilite", "TypCivilite");
    };

#>
<#
    // namespace
    string fileNamespace = Namespace;
    if (string.IsNullOrWhiteSpace(fileNamespace))
    {
        fileNamespace = VisualStudioHelper.CurrentFileNamespace;
    }

    Manager manager = Manager.Create(Host, GenerationEnvironment);
    manager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable 1591

using System;
using System.Collections.Generic;
using System.Net;
using System.Runtime.Serialization;
using ServiceStack;
using ServiceStack.DataAnnotations;
using ServiceStack.Model;

namespace <#= fileNamespace #>
{
<#
	manager.EndBlock(); // end header
    
    // get a reference to the project of this t4 template
    Project project = VisualStudioHelper.CurrentProject;

	// contient tous les enums du projet
    List<string> allEnums = VisualStudioHelper.CodeModel.GetAllCodeElementsOfType(project.CodeModel.CodeElements, vsCMElement.vsCMElementEnum, false)
        .OfType<CodeEnum>()
		.Select(x => x.Name)
		.ToList();

    // Read schema
    Tables allTables = LoadTables(ConnectionString, SchemaName, false, MakeSingular);
    if (TweakSchema != null)
    {
        TweakSchema(allTables);
    }

    foreach (Table table in allTables)
    {
        manager.StartNewFile(table.ClassName + ".generated.cs");

        List<string> lstInterfaces = new List<string>();

        if (table.PrimaryKey != null)
        {
			if (table.PrimaryKey.PKeyColumns.Count > 1)
            {
				string errorMsg = string.Format("[{0}].[{1}].[{2}] : OrmLite ne supporte pas les clés primaires composites ; la table est ignorée.",
					table.Schema, table.Name, table.PrimaryKey.Name);
				Error(errorMsg);
#>
	// <#= errorMsg #>
<#
				continue;
            }

			Column pkCol = table.PrimaryKey.PKeyColumns.Single();
            if (UseIdAsPK)
            {
                pkCol.PropertyName = "Id";
            }
            if (pkCol.PropertyName == "Id")
            {
                lstInterfaces.Add("IHasId<" + pkCol.PropertyType + ">");
            }
        }
        if (AddCustomInterfaces)
        {
            if (table.Columns.Any(c => c.PropertyName == "DatCreation" && c.ProperPropertyType == "DateTime") &&
                table.Columns.Any(c => c.PropertyName == "DatModif" && c.ProperPropertyType == "DateTime"))
            {
                lstInterfaces.Add("IAuditable");
            }
        }

        if (table.ClassName != table.Name)
        {
#>
	[Alias("<#= table.Name #>")]
<#
        }
		
        if (UseSchemaAttribute && !string.IsNullOrEmpty(table.Schema) && table.Schema != "dbo")
        {
#>
	[Schema("<#= table.Schema #>")]
<#
        }
		
        if (IncludeIndices)
        {
			IEnumerable<TableIndex> compositeIdx = table.Indices.Where(i => i.IndexColumns.Count > 1);
            foreach (TableIndex idx in compositeIdx)
            {
				IEnumerable<string> q = idx.IndexColumns
					.Select(c => (c.Name == c.PropertyName) ? string.Format("nameof({0})", c.PropertyName) : string.Format("\"{0}\"", c.Name));
#>
	[CompositeIndex(<#= idx.IsUnique ? "true, " : "" #><#= string.Join(", ", q) #>)]
<#
            }
        }

		string resourceName = table.ClassName;

        bool putExcluded = PutTableFilterExclude != null && PutTableFilterExclude.IsMatch(table.ClassName);
        bool postExcluded = PostTableFilterExclude != null && PostTableFilterExclude.IsMatch(table.ClassName);

        if (AddRouteAttributes && (!putExcluded || !postExcluded))
        {
	        List<Column> routeKeyParts = GetBestUniqueColumns(table, UsePKAsRouteId);

			string strRoute = table.ClassName;
            if (TransformRoutePath)
            {
                List<string> parts = GetRoutePartsFromTable(table, UsePKAsRouteId);

				FKey parentFKey = GetParentFKey(table);
				if (parentFKey != null)
                {
					routeKeyParts.RemoveAll(c => parentFKey.FromColumns.Contains(c));
                }
				strRoute = string.Join("/", parts);
            }

            if (!postExcluded)
            {
				string strRoutePostSuffix = "";
				bool routeKeyIsReadonly = routeKeyParts.Any(c => c.IsAutoIncrement || c.IsComputed);
                if (!routeKeyIsReadonly)
                {
                    strRoutePostSuffix = "/" + string.Join("/", routeKeyParts.Select(c => "{" + c.PropertyName + "}"));
                }
#>
    [Route("/<#= strRoute #><#= strRoutePostSuffix #>", HttpVerbs.Post, Summary = "<#= string.Format("Ajoute une ressource {0}.", resourceName) #>")]
<#
            }
            if (!putExcluded)
            {
                string strRoutePutSuffix = "/" + string.Join("/", routeKeyParts.Select(c => "{" + c.PropertyName + "}"));
#>
    [Route("/<#= strRoute #><#= strRoutePutSuffix #>", HttpVerbs.Put, Summary = "<#= string.Format("Remplace une ressource {0}.", resourceName) #>")]
<#
            }

            if (AddApiAttributes)
            {
#>
    [ApiResponse(HttpStatusCode.NotFound, "La ressource <#= resourceName #> spécifiée est introuvable.")]
<#
            }
        }
		
#>
	public <#= MakeClassesPartial ? "partial " : "" #>class <#= table.ClassName #><#= lstInterfaces.Any() ? " : " + string.Join(",\r\n\t\t", lstInterfaces) : "" #>
	{
<#
        if (GenerateEmptyConstructor)
        {
#>
        /// <summary>
        /// Initialise une nouvelle instance de la classe <see cref="<#= table.ClassName #>" />.
        /// </summary>
		public <#= table.ClassName #>()
		{
		}

<#
        }

        foreach (Column col in table.Columns)
        {
            if (!string.IsNullOrWhiteSpace(col.Description))
            {
                if (!col.Description.EndsWith("."))
                {
                    col.Description += ".";
                }
#>
		/// <summary>
		/// <#= col.Description #>
		/// </summary>
<#
			}
			if (col.Name != col.PropertyName)
			{
#>
        [Alias("<#= col.Name #>")]
<#
			}

			if (col.PropertyType == "string" && col.Size > 0)
			{   
#>
		[StringLength(<#= col.Size #>)]
<#
            }
			
            if (col.PropertyType == "decimal" && col.Precision > 0)
            {
#>
		[DecimalLength(<#= col.Precision #>, <#= col.Scale #>)]
<#
            }

            if (col.IsAutoIncrement)
            {
#>
		[AutoIncrement]
<#
            }

            if (col.IsComputed)
            {
#>
		[Compute]        
<#
            }

            if (IncludeReferences)
            {
                FKey fKey = table.ForeignKeys.Where(fk => fk.FromColumns.Contains(col)).FirstOrDefault();
                if (fKey != null)
                {
                    Table tbl = fKey.ReferencedTable;
                    if (string.IsNullOrEmpty(fKey.DeleteRule))
                    {
#>
		[References(typeof(<#= tbl.ClassName #>))]
<#
                    }
                    else
                    {
#>
		[ForeignKey(typeof(<#= tbl.ClassName #>), OnDelete = "<#= fKey.DeleteRule #>")]
<#
                    }
                }
            }

            if (col.IsNullable == false && col.IsAutoIncrement == false)
            {
#>
		[Required]
<#
            }

            if (IncludeIndices)
            {
				TableIndex index = table.Indices.Where(idx => idx.IndexColumns.Count == 1 && idx.IndexColumns.Contains(col)).FirstOrDefault();
                if (index != null)
                {
#>
		[Index<#= index.IsUnique ? "(true)" : "" #>]
<#
                }
            }

            if (col.IsPKey && (col.PropertyName != "Id"))
            {
#>
		[PrimaryKey]
<#
            }

            bool dataMemberIgnored = false;
            if (!UsePKAsRouteId) 
            {
				dataMemberIgnored = (col.IsPKey || col.IsFKey);
            }

            if (dataMemberIgnored)
            {
#>
        [IgnoreDataMember]
<#
            }
            else if (AddApiAttributes)
            {
				List<string> lstApiMemberProps = GetApiMemberProps(col, allEnums, lstInterfaces);
				if (lstApiMemberProps.Any())
                {
					if (col.IsPKey && (!putExcluded || !postExcluded))
					{
						if (!postExcluded)
						{
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>, Verb = HttpVerbs.Post)]
<#
						}
						if (!putExcluded)
						{
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>, Verb = HttpVerbs.Put, IsRequired = true, ParameterType = SwaggerParamTypes.Path)]
<#
						}
					}
					else
					{
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>)]
<#
					}
				}

                if (allEnums.Contains(col.PropertyType))
                {
#>
		[ApiAllowableValues(nameof(<#= col.PropertyName #>), typeof(<#= col.PropertyType #>))]
<#
                }

            }
#>
		public <#= MakePropertiesVirtual ? "virtual " : "" #><#= col.ProperPropertyType #> <#= col.PropertyName #> { get; set; }

<#
			if (!UsePKAsRouteId)
            {
				FKey thisFkey = table.ForeignKeys.Where(fk => fk.FromColumns.Contains(col)).FirstOrDefault();
                if (thisFkey != null)
				{
					Column fkFromCol = thisFkey.FromColumns.Single();
					Column fkRefCol = thisFkey.ReferencedColumns.Single();

					List<Column> lstNewFkCols = GetBestUniqueColumns(fkRefCol.ParentTable, UsePKAsRouteId);

					string format = fkFromCol.PropertyName.Replace(fkRefCol.PropertyName, "{0}");

					foreach (Column fkCol in lstNewFkCols)
                    { 
						Column newCol = fkCol.Clone();
						newCol.IsNullable = fkFromCol.IsNullable;
						string newDescription = fkFromCol.Description + " " +newCol.Description;
						newCol.Description = newDescription.Trim();
						newCol.PropertyName = string.Format(format, newCol.PropertyName);
#>
		/// <summary>
<#
						if (!string.IsNullOrEmpty(newCol.Description))
                        {
#>
		/// <#= newCol.Description #>
		/// </summary>
<#
						}
#>
        /// <remarks>
		/// Remplace la propriété <see cref="<#= col.PropertyName #>" /> dans la sérialisation.
		/// Référence la propriété <see cref="<#= fkCol.ParentTable.ClassName #>.<#= fkCol.PropertyName #>" />.
        /// </remarks>
<#
						if (AddApiAttributes)
						{
							List<string> lstApiMemberProps = GetApiMemberProps(newCol, allEnums, lstInterfaces);
							if (lstApiMemberProps.Any())
							{
#>
		[ApiMember(<#= string.Join(", ", lstApiMemberProps) #>)]
<#
							}
						}
#>
		[Ignore]
		public <#= MakePropertiesVirtual ? "virtual " : "" #><#= newCol.ProperPropertyType #> <#= newCol.PropertyName #> { get; set; }

<#
					}
				}
            }
        } // end foreach (col)

        if (AddChildReferences)
        {
           var q = from tbl in allTables
					where tbl.Name.StartsWith(table.Name)
					from fk in tbl.ForeignKeys
					where fk.ReferencedTable == table
					let fkCol = fk.FromColumns.Single()
					let fkIsPK = tbl.PrimaryKey != null && tbl.PrimaryKey.PKeyColumns.Contains(fkCol)
					let fkIsUnique = tbl.Indices.Any(idx => idx.IsUnique && idx.IndexColumns.Count == 1 && idx.IndexColumns.Contains(fkCol))
					select new
					{
						Table = tbl,
						IsUnique = fkIsPK || fkIsUnique
					};
            foreach (var obj in q)
            {
                string propType = obj.Table.ClassName;
                string propName = obj.Table.ClassName.Replace(table.ClassName, "");
                if (!obj.IsUnique)
                {
                    propType = "List<" + propType + ">";
                    propName = "Lst" + propName;
                }
#>
		[Reference]
		public <#= MakePropertiesVirtual ? "virtual " : "" #><#= propType #> <#= propName #> { get; set; }

<#
            }
        }
#>
	}
<#
        manager.EndBlock(); // end newfile
    } // end foreach (table)
	
    manager.StartFooter();
#>
}
<#
    manager.EndBlock(); // end footer
	
    manager.Process(SplitIntoMultipleFiles);
#>
<#+
void SetDescription(Table table)
{
	foreach(Column col in table.Columns.Where(c => string.IsNullOrWhiteSpace(c.Description)))
    {
		string stdColFormat = "";
		FKey parentFkey = GetParentFKey(table);
		if (parentFkey != null)
        {
			stdColFormat = parentFkey.FromTable.ClassName.Replace(parentFkey.ReferencedTable.ClassName, "{0}");
        }
		else
        {
			stdColFormat = "{0}" + table.Name.Remove(0, 3);
        }

        if (col.IsPKey)
        {
            col.Description = "Clé primaire.";
        }
        else if (col.PropertyName == string.Format(stdColFormat, "Cod"))
        {
			bool isUniqueSingleCol = table.Indices
				.Where(idx => idx.IsUnique == true && idx.IndexColumns.Count == 1 && idx.IndexColumns.Contains(col))
				.Any();
            col.Description = isUniqueSingleCol ? "Code unique." : "Code.";
        }
		else if (col.PropertyName == string.Format(stdColFormat, "Lib"))
        {
            col.Description = "Désignation.";
        }
		else if (col.PropertyName == string.Format(stdColFormat, "Txt"))
        {
            col.Description = "Commentaire ou description.";
        }
		else
		{
			switch (col.PropertyName)
			{
				case "EstActif":
					col.Description = "Actif ou inactif";
					break;
				case "DatCreation":
					col.Description = "Date de création.";
					break;
				case "DatModif":
					col.Description = "Date de dernière modification.";
					break;
				case "CodExterne":
					col.Description = "Identifiant de synchronisation externe.";
					break;

				case "NumTelep":
					col.Description = "Numéro de téléphone.";
					break;
				case "NumFax":
					col.Description = "Numéro de fax.";
					break;
				case "NumEmail":
					col.Description = "Adresse email.";
					break;

				case "AdrRue":
					col.Description = "Rue.";
					break;
				case "AdrCode":
					col.Description = "Code postal.";
					break;
				case "AdrCommune":
					col.Description = "Ville ou commune.";
					break;
				case "AdrPays":
					col.Description = "Pays.";
					break;
			}
        }
    }
}

List<string> GetApiMemberProps(Column col, List<string> lstEnums, List<string> lstInterfaces)
{
    List<string> lstApiMemberProps = new List<string>();

    if (!string.IsNullOrEmpty(col.Description))
    {
        lstApiMemberProps.Add("Description = \"" + col.Description + "\"");
    }
                
    string swagDataType = "";

    if (lstEnums.Contains(col.PropertyType))
    {
        //swagDataType = "SwaggerDataTypes.String";
    }
    else if (col.PropertyType == "byte[]")
    {
        swagDataType = "SwaggerDataTypes.File";
    }
    else
    {
        swagDataType = "SwaggerDataTypes." + col.PropertyType.Substring(0,1).ToUpper() + col.PropertyType.Substring(1);
    }

    if (!string.IsNullOrEmpty(swagDataType))
    {
        lstApiMemberProps.Add("DataType = " + swagDataType);
    }

    if (!col.IsPKey)
    {
        if (col.IsNullable == false && col.IsAutoIncrement == false)
        {
            bool required = true;
            if (lstInterfaces.Contains("IAuditable") && (col.ProperPropertyType == "DateTime")
                && (col.PropertyName == "DatCreation" || col.PropertyName == "DatModif"))
            {
                required = false;
            }
            if (required)
            {
                lstApiMemberProps.Add("IsRequired = true");
            }
        }
    }

	return lstApiMemberProps;
}

/// <summary>
/// Cherche parmi les PK ou les contraintes uniques les meilleures colonnes pour identifier la ressource.
/// </summary>
List<Column> GetBestUniqueColumns(Table table, bool usePK)
{
	List<Column> pkCols = null;

	if (table.PrimaryKey != null)
    {
		pkCols = table.PrimaryKey.PKeyColumns;
    }

	if (usePK)
    {
		return pkCols;
    }
	else 
    {
		TableIndex index = table.Indices.Where(idx => idx.IsUnique)
			.OrderBy(idx => idx.IndexColumns.Count)
			.FirstOrDefault();
		if (index != null)
		{
			return index.IndexColumns;
		}
    }

    return pkCols;
}

/// <summary>
/// Retourne la FK pointant sur la table parent la plus proche.
/// </summary>
FKey GetParentFKey(Table table)
{
    // si plusieurs parents, on prend celui avec le nom le plus long
    FKey fkey = table.ForeignKeys
		.Where(fk => table.Name.StartsWith(fk.ReferencedTable.Name))
		.OrderByDescending(fk => fk.ReferencedTable.Name.Length)
		.FirstOrDefault();
	return fkey;
}

/// <summary>
/// extraction du route path suivant les ForeignKeys/enfants
/// exemple : classe GenFournContact passe de '/GenFournContact/' en '/GenFourn/{xxx}/Contact/'
/// </summary>
List<string> GetRoutePartsFromTable(Table table, bool usePK)
{
    List<string> lstRoute = new List<string>();
    List<string> parts = new List<string>();

	FKey fkParent = GetParentFKey(table);
    if (fkParent != null)
    {
		Table parentTable = fkParent.ReferencedTable;
	    List<Column> parentCols = GetBestUniqueColumns(parentTable, usePK);
        if (parentCols != null)
        {
			Column fkFromCol = fkParent.FromColumns.Single();
			Column fkRefCol = fkParent.ReferencedColumns.Single();

			string format = fkFromCol.PropertyName.Replace(fkRefCol.PropertyName, "{0}");
			
            List<string> keys = parentCols.Select(c => "{" + string.Format(format, c.PropertyName) + "}").ToList();
            parts.AddRange(keys);
        }

        string newTableName = table.Name.Replace(parentTable.Name, "");
        parts.Add(newTableName);

        lstRoute = GetRoutePartsFromTable(parentTable, usePK);
    }
    if (!parts.Any())
    {
		string newTableName = table.Name.Remove(0, 3);
        parts.Add(newTableName);
    }

    lstRoute.AddRange(parts);
    return lstRoute;
}
#>