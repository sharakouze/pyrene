<#@ template language="C#" hostspecific="true" #>
<#@ include file="$(SolutionDir)Shared\MultipleOutputHelper.ttinclude" #>
<#@ include file="$(SolutionDir)Shared\VisualStudioHelper.ttinclude" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#
	/***** TODO *****
	- ApiAttribute + ApiMemberAttribute
	****************/

	/*********************/
	/** CUSTOM SETTINGS **/
	/*********************/

	// Namespace des fichiers générés. Si vide DefaultNamespace du projet/répertoire courant.
	string Namespace = "";

	// Limite le traitement aux classes dans ce namespace. Si vide pas de limitation.
	string SourceNamespace = "Tmpi.Pyrene.Services.ServiceModel.Types";
	
	// true pour générer des classes partial.
	bool MakeClassesPartial = true;

	// true pour générer chaque classe dans un fichier séparé.
	bool SplitIntoMultipleFiles = true;
	
	// true pour ajouter l'attribut [Route(...)] sur les classes générées.
	bool AddRouteAttributes = true;

	// true pour transformer la route de la ressource, ex: GenFournContact de '/GenFournContact/' en '/GenFourn/Contact/'.
	bool TransformRoutePath = true;

	// RegExp pour filtrer globalement les classes traitées, null pour tout inclure et/ou ne rien exclure.
	Regex ClassFilterInclude = new Regex("^Gen", RegexOptions.IgnoreCase);
	Regex ClassFilterExclude = null;

	// Filtre par message généré.
	Regex GetByIdClassFilterExclude = null;
	Regex DeleteByIdClassFilterExclude = null;
	Regex PatchByIdClassFilterExclude = null;
	Regex PutByIdAndPostClassFilterExclude = null;
	Regex AutocompleteClassFilterExclude = null;

#>
<#
	// namespace
	var fileNamespace = Namespace;
	if (string.IsNullOrWhiteSpace(fileNamespace))
	{
		fileNamespace = VisualStudioHelper.CurrentFileNamespace;
	}

	var manager = Manager.Create(Host, GenerationEnvironment);
	manager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Net;
using ServiceStack;
<#
	if (!string.IsNullOrWhiteSpace(SourceNamespace) && (SourceNamespace != fileNamespace))
	{
#>
using <#= SourceNamespace #>;

<#
	} // end if

	manager.EndBlock(); // end header
 
	// get a reference to the project of this t4 template
	var project = VisualStudioHelper.CurrentProject;

	// get all class items from the code model
	var allClasses = VisualStudioHelper.CodeModel.GetAllCodeElementsOfType(project.CodeModel.CodeElements, EnvDTE.vsCMElement.vsCMElementClass, false);
	if (!string.IsNullOrWhiteSpace(SourceNamespace))
	{
		allClasses = allClasses.Where(c => c.FullName.StartsWith(SourceNamespace)).ToList();
	}

	// transformation du route path suivant les attributs ForeignKey
	// exemple : classe GenFournContact passe de '/GenFournContact/' en '/GenFourn/Contact/'
	Func<EnvDTE.CodeClass, List<string>> getRoutePathFromClass = null;
	getRoutePathFromClass = codeClass =>
	{
		var lstRoute = new List<string>();
		string str = null;

		var allAttributes = VisualStudioHelper.CodeModel.GetAllPropertiesAttributes(codeClass);
		var fkAttributes = allAttributes.Where(attr => attr.FullName == "ServiceStack.DataAnnotations.ReferencesAttribute" || 
			attr.FullName == "ServiceStack.DataAnnotations.ForeignKeyAttribute").ToList();
		if (fkAttributes.Any())
		{
			var refClassNames = fkAttributes.SelectMany(fk => fk.Value.Split(',')).Select(s => s.Trim())
				.Where(s => s.StartsWith("typeof(") && s.EndsWith(")"))
				.Select(s => s.Remove(s.Length-1, 1).Remove(0, 7).Trim()) // nettoyage
				.Where(s => codeClass.Name.StartsWith(s))
				.ToList();

			string refClassName = refClassNames.OrderByDescending(s => s.Length).FirstOrDefault();
			if (!string.IsNullOrEmpty(refClassName))
			{
				var cls = allClasses.SingleOrDefault(c => c.Name == refClassName) as EnvDTE.CodeClass;
				if (cls != null)
				{
					str = codeClass.Name.Replace(cls.Name, "");
					lstRoute = getRoutePathFromClass(cls);
				}
			}
		}
		if (string.IsNullOrEmpty(str))
		{
			str = codeClass.Name;
		}

		lstRoute.Add(str);
		return lstRoute;
	};

	// iterate all classes
	foreach (EnvDTE.CodeClass codeClass in allClasses)
	{
		bool included = ClassFilterInclude == null || ClassFilterInclude.IsMatch(codeClass.Name);
		bool excluded = ClassFilterExclude != null && ClassFilterExclude.IsMatch(codeClass.Name);
		if (!included || excluded)
		{
			continue;
		}

		var classDefinitionWords = new List<string>();
		classDefinitionWords.Add("public");
		if (MakeClassesPartial)
		{
			classDefinitionWords.Add("partial");
		}

		string strRoute = codeClass.Name;
		if (AddRouteAttributes && TransformRoutePath)
		{
			strRoute = string.Join("/", getRoutePathFromClass(codeClass));
		}

		// get all interfaces implemented by this class
		var allInterfaces = VisualStudioHelper.CodeModel.GetAllImplementedInterfaces(codeClass);
		var iHasIdInterface = allInterfaces.FirstOrDefault(i => i.FullName.StartsWith("ServiceStack.Model.IHasId<") ||
			i.FullName == "ServiceStack.Model.IHasIntId");
		if (iHasIdInterface != null)
		{
			string tkey = null;
			if (iHasIdInterface.FullName == "ServiceStack.Model.IHasIntId")
            {
				tkey = "int";
            }
			else
			{
				string str = iHasIdInterface.FullName.Replace("ServiceStack.Model.IHasId<", "");
				str = str.Remove(str.Length - 1, 1);

				switch (str)
                {
					case "System.Int32":
						tkey = "int";
						break;
					case "System.Int16":
						tkey = "short";
						break;
					default:
						tkey = str;
						break;
                }
			}

			bool getByIdExcluded = GetByIdClassFilterExclude != null && GetByIdClassFilterExclude.IsMatch(codeClass.Name);
			if (!getByIdExcluded)
			{
				var getByIdClassName = "Get" + codeClass.Name;
				var getByIdDescription = "Retourne une ressource {0} à partir de son Id.";

				manager.StartNewFile(getByIdClassName + ".generated.cs");
#>
namespace <#= fileNamespace #>
{
	/// <summary>
	/// <#= string.Format(getByIdDescription, "<see cref=\"" + codeClass.Name + "\" />") #>
	/// </summary>
    [ApiResponse(HttpStatusCode.NotFound, "La ressource <#= codeClass.Name #> spécifiée est introuvable.")]
<#
			if (AddRouteAttributes)
            {
#>
	[Route("/<#= strRoute #>/{Id}", HttpVerbs.Get, Summary = "<#= string.Format(getByIdDescription, codeClass.Name) #>")]
<#
			} // end if
#>
	<#= string.Join(" ", classDefinitionWords) #> class <#= getByIdClassName #> : GetByIdRequestBase<<#= tkey #>, <#= codeClass.Name #>>
	{
	}
}
<#
				manager.EndBlock(); // end newfile
			} // end if

			bool deleteByIdExcluded = DeleteByIdClassFilterExclude != null && DeleteByIdClassFilterExclude.IsMatch(codeClass.Name);
			if (!deleteByIdExcluded)
			{
				var deleteByIdClassName = "Delete" + codeClass.Name;
				var deleteByIdDescription = "Supprime une ressource {0} à partir de son Id.";

				manager.StartNewFile(deleteByIdClassName + ".generated.cs");
#>
namespace <#= fileNamespace #>
{
	/// <summary>
	/// <#= string.Format(deleteByIdDescription, "<see cref=\"" + codeClass.Name + "\" />") #>
	/// </summary>
    [ApiResponse(HttpStatusCode.NotFound, "La ressource <#= codeClass.Name #> spécifiée est introuvable.")]
<#
			if (AddRouteAttributes)
            {
#>
	[Route("/<#= strRoute #>/{Id}", HttpVerbs.Delete, Summary = "<#= string.Format(deleteByIdDescription, codeClass.Name) #>")]
<#
			} // end if
#>
	<#= string.Join(" ", classDefinitionWords) #> class <#= deleteByIdClassName #> : DeleteByIdRequestBase<<#= tkey #>>
	{
	}
}
<#
				manager.EndBlock(); // end newfile
            }

			bool patchByIdExcluded = PatchByIdClassFilterExclude != null && PatchByIdClassFilterExclude.IsMatch(codeClass.Name);
			if (!patchByIdExcluded)
            {
				var patchClassName = "Patch" + codeClass.Name;
				var patchDescription = "Modifie une ressource {0} à partir de son Id.";
				
				manager.StartNewFile(patchClassName + ".generated.cs");
#>
namespace <#= fileNamespace #>
{
	/// <summary>
	/// <#= string.Format(patchDescription, "<see cref=\"" + codeClass.Name + "\" />") #>
	/// </summary>
    [ApiResponse(HttpStatusCode.NotFound, "La ressource <#= codeClass.Name #> spécifiée est introuvable.")]
<#
			if (AddRouteAttributes)
            {
#>
	[Route("/<#= strRoute #>/{Id}", HttpVerbs.Patch, Summary = "<#= string.Format(patchDescription, codeClass.Name) #>")]
<#
			} // end if
#>
	<#= string.Join(" ", classDefinitionWords) #> class <#= patchClassName #> : PatchByIdRequestBase<<#= tkey #>>
	{
	}
}
<#
				manager.EndBlock(); // end newfile
            }
			
			bool putByIdAndPostExcluded = PutByIdAndPostClassFilterExclude != null && PutByIdAndPostClassFilterExclude.IsMatch(codeClass.Name);
			if (!putByIdAndPostExcluded)
            {
				if (AddRouteAttributes)
                {
					manager.StartNewFile(codeClass.Name + ".generated.cs");
#>
namespace <#= codeClass.Namespace == null ? fileNamespace : codeClass.Namespace.Name #>
{
    [ApiResponse(HttpStatusCode.NotFound, "La ressource <#= codeClass.Name #> spécifiée est introuvable.")]
	[Route("/<#= strRoute #>", HttpVerbs.Post, Summary = "<#= string.Format("Ajoute une ressource {0}.", codeClass.Name) #>")]
	[Route("/<#= strRoute #>/{Id}", HttpVerbs.Put, Summary = "<#= string.Format("Remplace une ressource {0} à partir de son Id.", codeClass.Name) #>")]
	partial class <#= codeClass.Name #>
	{
	}
}
<#
					manager.EndBlock(); // end newfile
                } // end if
            } // end if
        } // end if

		if (allInterfaces.Any(i => i.FullName == "Tmpi.Pyrene.Services.ServiceModel.Types.IHasStandard"))
        {
			bool autocompleteExcluded = AutocompleteClassFilterExclude != null && AutocompleteClassFilterExclude.IsMatch(codeClass.Name);
			if (!autocompleteExcluded)
            {
				var autocompleteClassName = "Autocomplete" + codeClass.Name;
				var autocompleteDescription = "Autocomplete une ressource {0}.";

				manager.StartNewFile(autocompleteClassName + ".generated.cs");
#>
namespace <#= fileNamespace #>
{
	/// <summary>
	/// <#= string.Format(autocompleteDescription, "<see cref=\"" + codeClass.Name + "\" />") #>
	/// </summary>
<#
			if (AddRouteAttributes)
            {
#>
	[Route("/<#= strRoute #>/Autocomplete", HttpVerbs.Get, Summary = "<#= string.Format(autocompleteDescription, codeClass.Name) #>")]
<#
			} // end if
#>
	<#= string.Join(" ", classDefinitionWords) #> class <#= autocompleteClassName #> : AutocompleteRequestBase
	{
	}
}
<#
				manager.EndBlock(); // end newfile
            } // end if
		} // end if
    } // end foreach

	manager.Process(SplitIntoMultipleFiles);
#>
